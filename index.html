
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D flight tracker thingy</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Real-time 3D visualization of aircraft flight paths. Watch live flights with stunning ribbon trails across the sky.">
    <meta name="keywords" content="flight tracker, 3d visualization, aircraft tracking, live flights, air traffic, flight paths, aviation">
    <meta name="author" content="Objective Unclear">
    <link rel="canonical" href="https://objectiveunclear.com/airloom.html">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Air Loom - 3D Flight Tracker">
    <meta name="twitter:description" content="Real-time 3D visualization of aircraft flight paths. Watch live flights with stunning ribbon trails across the sky.">
    <meta name="twitter:image" content="https://objectiveunclear.com/images/airloom.png">
    <meta name="twitter:image:alt" content="Air Loom 3D Flight Tracker showing aircraft trails">

    <!-- Open Graph / Facebook / LinkedIn / Discord -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Air Loom - 3D Flight Tracker">
    <meta property="og:description" content="Real-time 3D visualization of aircraft flight paths. Watch live flights with stunning ribbon trails across the sky.">
    <meta property="og:image" content="https://objectiveunclear.com/images/airloom.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:url" content="https://objectiveunclear.com/airloom.html">
    <meta property="og:site_name" content="Air Loom">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
            touch-action: none;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #menu-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #menu-toggle:hover {
            background: #45a049;
        }
        #menu-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 320px;
            max-width: 90vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(76, 175, 80, 0.3);
            z-index: 999;
            overflow-y: auto;
            transition: right 0.3s ease;
            padding: 80px 20px 20px 20px;
        }
        #menu-panel.open {
            right: 0;
        }
        .menu-section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .menu-section:last-child {
            border-bottom: none;
        }
        .menu-section h3 {
            color: #4CAF50;
            font-size: 14px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .menu-buttons button {
            width: 100%;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .stat-label {
            color: #888;
        }
        .stat-value {
            color: #4CAF50;
            font-weight: bold;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        button:hover {
            background: #45a049;
        }
        button:active {
            transform: scale(0.95);
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        .slider-group label {
            font-size: 12px;
            color: #ccc;
            display: flex;
            justify-content: space-between;
        }
        input[type="range"] {
            width: 100%;
            accent-color: #4CAF50;
        }

        /* Mobile-friendly slider improvements */
        @media (max-width: 768px) {
            input[type="range"] {
                height: 40px; /* Larger touch target */
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
            }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 24px;
                height: 24px;
                background: #4CAF50;
                cursor: pointer;
                border-radius: 50%;
            }

            input[type="range"]::-moz-range-thumb {
                width: 24px;
                height: 24px;
                background: #4CAF50;
                cursor: pointer;
                border-radius: 50%;
                border: none;
            }

            input[type="range"]::-webkit-slider-runnable-track {
                height: 6px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 3px;
            }

            input[type="range"]::-moz-range-track {
                height: 6px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 3px;
            }
        }

        .radius-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radius-fine-tune {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            margin-top: 5px;
        }

        .radius-fine-tune button {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            min-width: 45px;
            transition: all 0.2s;
        }

        .radius-fine-tune button:hover,
        .radius-fine-tune button:active {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }
        .filter-group {
            margin-bottom: 15px;
        }
        .filter-group label {
            display: block;
            font-size: 12px;
            color: #ccc;
            margin-bottom: 8px;
        }
        .filter-group select, .filter-group input {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }
        .filter-group select:focus, .filter-group input:focus {
            outline: none;
            border-color: #4CAF50;
        }
        /* Explicit styling for airport dropdown to ensure visibility on all platforms */
        #airport-select {
            background-color: #2d2d2d !important;
            color: #ffffff !important;
            border: 1px solid #444 !important;
        }
        #airport-select option {
            background-color: #2d2d2d;
            color: #ffffff;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            accent-color: #4CAF50;
        }
        .checkbox-group label {
            font-size: 12px;
            color: #ccc;
            margin: 0;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #4CAF50;
            z-index: 1000;
        }
        .aircraft-info-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            border: 1px solid rgba(76, 175, 80, 0.5);
            transition: all 0.2s ease;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            white-space: nowrap;
        }
        .aircraft-info-label:hover {
            background: rgba(0, 0, 0, 0.95);
            border-color: #4CAF50;
        }
        .aircraft-info-label.expanded {
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4CAF50;
            padding: 12px 16px;
            white-space: normal;
            width: 200px;
            font-size: 12px;
        }
        .label-callsign {
            font-weight: bold;
            color: #4CAF50;
            display: block;
            margin-bottom: 4px;
        }
        .label-details {
            display: none;
        }
        .aircraft-info-label.expanded .label-details {
            display: block;
        }
        .label-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 11px;
        }
        .label-key {
            color: #888;
        }
        .label-val {
            color: #fff;
            font-weight: bold;
        }
        /* Aircraft Photo Styles */
        .aircraft-photo-container {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .aircraft-photo-container a {
            display: block;
            margin-bottom: 6px;
            transition: opacity 0.2s ease;
        }
        .aircraft-photo-container a:hover {
            opacity: 0.85;
        }
        .aircraft-photo-container img {
            width: 100%;
            height: auto;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: block;
        }
        .aircraft-photo-loading {
            text-align: center;
            padding: 10px;
            color: #888;
            font-size: 10px;
        }
        .aircraft-photo-error {
            text-align: center;
            padding: 6px;
            color: #666;
            font-size: 9px;
            font-style: italic;
        }
        .aircraft-photo-credit {
            font-size: 9px;
            color: #888;
            text-align: center;
            margin-top: 4px;
        }
        .aircraft-photo-credit a {
            color: #4CAF50;
            text-decoration: none;
        }
        .aircraft-photo-credit a:hover {
            text-decoration: underline;
        }
        /* Playback Speed Buttons */
        .speed-btn {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 1px solid #4CAF50;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s;
        }
        .speed-btn.active {
            background: #4CAF50;
            color: white;
        }
        .speed-btn:hover {
            background: rgba(76, 175, 80, 0.4);
        }
        .memory-indicator {
            font-size: 11px;
            color: #888;
            text-align: center;
        }
        .memory-indicator.warning {
            color: #ff9800;
        }
        .memory-indicator.critical {
            color: #f44336;
        }

        /* Flight Search */
        .search-container {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .search-input {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 5px;
            color: white;
            font-size: 13px;
            text-transform: uppercase;
        }
        .search-input:focus {
            outline: none;
            border-color: #4CAF50;
            background: rgba(255, 255, 255, 0.15);
        }
        .search-input::placeholder {
            color: #888;
            text-transform: none;
        }
        .search-btn {
            padding: 10px 16px;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.3s;
            white-space: nowrap;
        }
        .search-btn:hover {
            background: #45a049;
        }
        .search-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .share-flight-btn:hover,
        .share-flight-menu-btn:hover:not(:disabled) {
            background: rgba(59, 130, 246, 1) !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }
        .share-flight-btn:active,
        .share-flight-menu-btn:active:not(:disabled) {
            transform: translateY(0);
        }
        .share-flight-menu-btn {
            transition: all 0.2s ease;
        }
        .search-status {
            margin-top: 8px;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }
        .search-status.searching {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            color: #ff9800;
        }
        .search-status.success {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }
        .search-status.error {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        /* Airport Autocomplete */
        .airport-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(30, 30, 30, 0.98);
            border: 1px solid #444;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .airport-suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            transition: background 0.2s;
            font-size: 13px;
        }
        .airport-suggestion-item:hover {
            background: rgba(59, 130, 246, 0.2);
        }
        .airport-suggestion-item:last-child {
            border-bottom: none;
        }
        .airport-code {
            color: #3b82f6;
            font-weight: bold;
            font-size: 14px;
        }
        .airport-name {
            color: #fff;
            margin-left: 8px;
        }
        .airport-location {
            color: #888;
            font-size: 11px;
            margin-top: 2px;
        }
        .airport-loading {
            padding: 12px;
            text-align: center;
            color: #ff9800;
            font-size: 12px;
        }
        .airport-no-results {
            padding: 12px;
            text-align: center;
            color: #888;
            font-size: 12px;
        }

        /* Compass */
        #compass {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 80px;
            height: 80px;
            cursor: pointer;
            z-index: 200;
            pointer-events: all;
            display: none;
        }
        #compass:hover {
            opacity: 0.9;
        }
        #compass svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        /* Hide fly mode button on mobile/tablet */
        @media (max-width: 1024px) {
            #toggle-controls {
                display: none;
            }
        }
    </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MT7KZ5JC72"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MT7KZ5JC72');
</script>
<body>
    <div id="container"></div>
    <div id="loading">Initializing 3D Space...</div>

    <button id="menu-toggle">☰</button>

    <!-- Compass -->
    <div id="compass">
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <!-- Outer circle -->
            <circle cx="50" cy="50" r="45" fill="rgba(0, 0, 0, 0.7)" stroke="rgba(76, 175, 80, 0.8)" stroke-width="2"/>

            <!-- Rotating inner group -->
            <g id="compass-inner">
                <!-- Cardinal direction markers -->
                <line x1="50" y1="10" x2="50" y2="20" stroke="#f44336" stroke-width="3"/>
                <text x="50" y="35" text-anchor="middle" fill="#f44336" font-size="16" font-weight="bold">N</text>

                <line x1="50" y1="80" x2="50" y2="90" stroke="#aaa" stroke-width="2"/>
                <text x="50" y="75" text-anchor="middle" fill="#aaa" font-size="12">S</text>

                <line x1="90" y1="50" x2="80" y2="50" stroke="#aaa" stroke-width="2"/>
                <text x="75" y="55" text-anchor="middle" fill="#aaa" font-size="12">E</text>

                <line x1="10" y1="50" x2="20" y2="50" stroke="#aaa" stroke-width="2"/>
                <text x="25" y="55" text-anchor="middle" fill="#aaa" font-size="12">W</text>

                <!-- Tick marks every 45 degrees -->
                <line x1="71" y1="21" x2="76" y2="16" stroke="#666" stroke-width="1"/>
                <line x1="79" y1="29" x2="84" y2="24" stroke="#666" stroke-width="1"/>
                <line x1="79" y1="71" x2="84" y2="76" stroke="#666" stroke-width="1"/>
                <line x1="71" y1="79" x2="76" y2="84" stroke="#666" stroke-width="1"/>
                <line x1="29" y1="79" x2="24" y2="84" stroke="#666" stroke-width="1"/>
                <line x1="21" y1="71" x2="16" y2="76" stroke="#666" stroke-width="1"/>
                <line x1="21" y1="29" x2="16" y2="24" stroke="#666" stroke-width="1"/>
                <line x1="29" y1="21" x2="24" y2="16" stroke="#666" stroke-width="1"/>
            </g>

            <!-- Center dot -->
            <circle cx="50" cy="50" r="3" fill="#4CAF50"/>
        </svg>
    </div>

    <div id="menu-panel">
        <!-- Share and Mailing List Buttons -->
        <div class="menu-section" style="padding-bottom: 10px;">
            <button id="menu-share-flight-btn" class="share-flight-menu-btn" style="width: 100%; padding: 10px; background: rgba(59, 130, 246, 0.8); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; gap: 6px; opacity: 1; font-weight: 500;">
                <span> </span>
                <span>Share Website</span>
            </button>
            <a href="https://epiccheese-yvl.github.io/" target="_blank" style="text-decoration: none;">
                <button style="width: 100%; margin-top: 8px; padding: 10px; background: rgba(76, 175, 80, 0.8); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; gap: 6px; font-weight: 500;">
                    <span> </span>
                    <span>My other website</span>
                </button>
            </a>
        </div>

        <div class="menu-section">
            <h3>Location</h3>
            <div class="filter-group" style="position: relative;">
                <label for="airport-search-input">Search Airport</label>
                <input
                    type="text"
                    id="airport-search-input"
                    class="search-input"
                    placeholder="Type airport name or code..."
                    autocomplete="off"
                    style="width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid #444; border-radius: 4px; color: white; font-size: 13px;"
                >
                <div id="airport-suggestions" class="airport-suggestions" style="display: none;"></div>
            </div>
            <button id="use-my-location" style="width: 100%; margin-top: 10px;">Use My Location</button>
            <div class="filter-group" style="margin-top: 10px;">
                <label>Current: <span id="location">Detecting...</span></label>
            </div>
            <div class="slider-group" style="margin-top: 15px;">
                <label>
                    <span>Search Radius (km)</span>
                    <span id="search-radius-value">100</span>
                </label>

                <div class="radius-controls">
                    <!-- Slider with logarithmic scale -->
                    <input type="range" id="search-radius" min="0" max="100" step="1" value="50">

                    <!-- Fine-tune controls -->
                    <div class="radius-fine-tune">
                        <button id="radius-decrease">-</button>
                        <button id="radius-increase">+</button>
                    </div>
                </div>
            </div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                <label style="font-size: 12px; font-weight: bold; color: #aaa;">Flight/Aircraft Search</label>
                <div class="search-container">
                    <input type="text" id="flight-search-input" class="search-input" placeholder="Callsign or Hex (e.g. UAL123 or A1B2C3)" maxlength="10">
                    <button id="flight-search-btn" class="search-btn">Search</button>
                </div>
                <div id="search-status" style="display: none;"></div>
            </div>
        </div>

        <div class="menu-section">
            <h3>Stats</h3>
            <div class="stat-row">
                <span class="stat-label">Aircraft:</span>
                <span class="stat-value" id="aircraft-count">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Update:</span>
                <span class="stat-value" id="last-update">--</span>
            </div>
        </div>

        <div class="menu-section">
            <h3>Controls & Navigation</h3>
            <div class="menu-buttons">
                <button id="reset-camera">Reset View</button>
                <button id="clear-trails">Clear Trails</button>
                <button id="toggle-controls">Fly Mode (WASD)</button>
            </div>
            <div class="checkbox-group" style="margin-top: 15px;">
                <input type="checkbox" id="auto-rotate" checked>
                <label for="auto-rotate">Auto-rotate after idle (10s)</label>
            </div>
            <div class="checkbox-group" style="margin-top: 10px;">
                <input type="checkbox" id="show-compass">
                <label for="show-compass">Show compass</label>
            </div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                <label style="font-size: 12px; font-weight: bold; color: #aaa;">Flight Following</label>
                <div class="checkbox-group" style="margin-top: 10px;">
                    <input type="checkbox" id="follow-aircraft" checked>
                    <label for="follow-aircraft">Enable Flight Following</label>
                </div>
                <div class="checkbox-group" style="margin-top: 10px;">
                    <input type="checkbox" id="surf-mode">
                    <label for="surf-mode">Surf Mode</label>
                </div>
                <div style="margin-top: 5px;">
                    <label style="font-size: 11px; color: #888;">Click aircraft to select • Surf auto-switches flights</label>
                </div>
                <div id="followed-aircraft-info" style="margin-top: 5px; display: none;">
                    <label style="font-size: 11px; color: #4CAF50;">Following: <span id="followed-aircraft-name">--</span></label>
                </div>
            </div>
        </div>

        <div class="menu-section">
            <h3>Display Settings</h3>
            <div class="slider-group">
                <label>
                    <span>Trail Length</span>
                    <span id="trail-length-value">1000</span>
                </label>
                <input type="range" id="trail-length" min="10" max="20000" value="1000">
            </div>
            <div class="slider-group">
                <label>
                    <span>Line Thickness</span>
                    <span id="line-thickness-value">2</span>
                </label>
                <input type="range" id="line-thickness" min="0.5" max="10" step="0.5" value="2">
            </div>
            <div class="checkbox-group" style="margin-top: 15px;">
                <input type="checkbox" id="color-by-speed">
                <label for="color-by-speed">Color by speed (vs altitude)</label>
            </div>
            <div class="checkbox-group" style="margin-top: 10px;">
                <input type="checkbox" id="show-airport-labels" checked>
                <label for="show-airport-labels">Show airport label</label>
            </div>
            <div class="checkbox-group" style="margin-top: 10px; margin-left: 20px;">
                <input type="checkbox" id="label-show-city" checked>
                <label for="label-show-city">Show city name</label>
            </div>
            <div class="checkbox-group" style="margin-top: 10px; margin-left: 20px;">
                <input type="checkbox" id="label-standing" checked>
                <label for="label-standing">Standing orientation</label>
            </div>
        </div>

        <div class="menu-section">
            <h3>Map & Terrain</h3>
            <div class="filter-group">
                <label for="map-layer-select">Map Layer</label>
                <select id="map-layer-select">
                    <option value="none">None</option>
                    <option value="dark">Dark (labels)</option>
                    <option value="dark-nolabels">Dark (no labels)</option>
                    <option value="dark-terrain" selected>3D - dark (labels)</option>
                    <option value="dark-nolabels-terrain">3D - dark (no labels)</option>
                    <option value="satellite">Satellite</option>
                    <option value="wireframe">Wireframe</option>
                </select>
            </div>
            <div class="filter-group" style="margin-top: 10px;">
                <label>GPS Elevation: <span id="gps-elevation">--</span> ft</label>
            </div>
            <div class="checkbox-group" style="margin-top: 10px;">
                <input type="checkbox" id="show-boundaries" checked>
                <label for="show-boundaries">Show Borders</label>
            </div>
        </div>

        <div class="menu-section">
            <h3>Airspace</h3>
            <div class="checkbox-group">
                <input type="checkbox" id="show-airspace">
                <label for="show-airspace">Show Airspace</label>
            </div>
            <div class="checkbox-group" style="margin-left: 20px;">
                <input type="checkbox" id="show-class-b" checked>
                <label for="show-class-b">Class B (Major)</label>
            </div>
            <div class="checkbox-group" style="margin-left: 20px;">
                <input type="checkbox" id="show-class-c" checked>
                <label for="show-class-c">Class C (Mid)</label>
            </div>
            <div class="checkbox-group" style="margin-left: 20px;">
                <input type="checkbox" id="show-class-d" checked>
                <label for="show-class-d">Class D (Small)</label>
            </div>
            <div class="checkbox-group" style="margin-left: 20px;">
                <input type="checkbox" id="airspace-focus-only" checked>
                <label for="airspace-focus-only">Focus Radius Only</label>
            </div>
            <div class="checkbox-group" style="margin-left: 20px;">
                <input type="checkbox" id="airspace-wireframe-only">
                <label for="airspace-wireframe-only">Wireframe Only (no fill)</label>
            </div>
            <div class="slider-group" style="margin-top: 15px;">
                <label>
                    <span>Airspace Opacity</span>
                    <span id="airspace-opacity-value">0.3</span>
                </label>
                <input type="range" id="airspace-opacity" min="0.1" max="0.8" step="0.1" value="0.3">
            </div>
        </div>

        <div class="menu-section" style="display: none;">
            <h3>Data Settings</h3>
            <div class="slider-group">
                <label>
                    <span>Update Rate (sec)</span>
                    <span id="update-rate-value">1</span>
                </label>
                <input type="range" id="update-rate" min="1" max="30" value="1">
            </div>
        </div>

        <div class="menu-section">
            <h3>Filters</h3>
            <div class="checkbox-group" style="margin-bottom: 15px;">
                <input type="checkbox" id="filter-remove-mode">
                <label for="filter-remove-mode">Remove filtered aircraft (vs hide)</label>
            </div>
            <div class="filter-group">
                <label for="filter-callsign">Callsign / Hex</label>
                <input type="text" id="filter-callsign" placeholder="e.g. UAL123, A1B2C3">
            </div>
            <div class="filter-group">
                <label for="filter-type">Aircraft Type</label>
                <input type="text" id="filter-type" placeholder="e.g. B738, A320">
            </div>
            <div class="filter-group">
                <label for="filter-altitude-min">Min Altitude (ft)</label>
                <input type="number" id="filter-altitude-min" placeholder="0">
            </div>
            <div class="filter-group">
                <label for="filter-altitude-max">Max Altitude (ft)</label>
                <input type="number" id="filter-altitude-max" value="100000">
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="filter-ground" checked>
                <label for="filter-ground">Show on ground</label>
            </div>
            <button id="reset-filters" style="width: 100%; margin-top: 15px;">Reset Filters</button>
        </div>

        <div class="menu-section">
            <h3>Recording & Playback</h3>
            <div class="menu-buttons">
                <button id="menu-record-btn">Start Recording</button>
                <button id="play-recording-btn" style="display: none;">Play Recording</button>
                <button id="play-pause-btn" style="display: none;">▶ Play</button>
                <button id="stop-playback-btn" style="display: none;">⏹ Stop</button>
                <button id="save-recording-btn" style="display: none;">Save Recording</button>
                <button id="load-recording-btn">Load Recording</button>
                <button id="clear-recording-btn" style="display: none;">Clear Recording</button>
            </div>
            <div class="stat-row" style="margin-top: 10px;">
                <span class="stat-label">Recording:</span>
                <span class="stat-value" id="recording-status">Inactive</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Duration:</span>
                <span class="stat-value" id="recording-duration">0:00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Memory:</span>
                <span class="stat-value" id="recording-memory">0 MB</span>
            </div>

            <!-- Playback Timeline -->
            <div id="timeline-container" style="display: none; margin-top: 15px;">
                <label style="font-size: 12px; color: #ccc; margin-bottom: 5px; display: block;">Playback Timeline</label>
                <input type="range" id="timeline-slider" min="0" max="100" value="0" style="width: 100%; accent-color: #4CAF50;">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-top: 5px;">
                    <span id="current-time">0:00</span>
                    <span id="total-time">0:00</span>
                </div>
            </div>

            <!-- Playback Speed Controls -->
            <div id="speed-controls" style="display: none; margin-top: 15px;">
                <label style="font-size: 12px; color: #ccc; margin-bottom: 8px; display: block;">Playback Speed</label>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;">
                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="4">4x</button>
                    <button class="speed-btn" data-speed="8">8x</button>
                    <button class="speed-btn" data-speed="16">16x</button>
                    <button class="speed-btn" data-speed="32">32x</button>
                    <button class="speed-btn" data-speed="64">64x</button>
                    <button class="speed-btn" data-speed="100">100x</button>
                </div>
            </div>

            <div id="memory-indicator" style="margin-top: 10px;"></div>
        </div>

        <div class="menu-section">
            <h3>Advanced Settings</h3>

            <div class="slider-group">
                <label>
                    <span>Altitude Scale</span>
                    <span id="altitude-scale-value">1.2</span>
                </label>
                <input type="range" id="altitude-scale" min="0.05" max="10.0" step="0.05" value="1.2">
            </div>

            <div class="slider-group">
                <label>
                    <span>Ground Elevation (ft)</span>
                    <span id="floor-height-value">0</span>
                </label>
                <input type="range" id="floor-height" min="-1000" max="15000" step="100" value="0">
            </div>

            <div class="slider-group">
                <label>
                    <span>Fog Distance</span>
                    <span id="fog-distance-value">20000</span>
                </label>
                <input type="range" id="fog-distance" min="500" max="20000" step="100" value="20000">
            </div>

            <div class="checkbox-group" style="margin-top: 15px;">
                <input type="checkbox" id="show-axes">
                <label for="show-axes">Show coordinate axes</label>
            </div>

            <div class="checkbox-group" style="margin-top: 10px;">
                <input type="checkbox" id="show-grid">
                <label for="show-grid">Show ground grid</label>
            </div>

            <div class="checkbox-group" style="margin-top: 10px;">
                <input type="checkbox" id="focused-tiles-mode" checked>
                <label for="focused-tiles-mode">Focused mode (show within search radius)</label>
            </div>

            <div class="slider-group" style="margin-top: 15px;">
                <label>
                    <span style="font-size: 11px;">Map Brightness</span>
                    <span id="map-brightness-value" style="font-size: 11px;">160%</span>
                </label>
                <input type="range" id="map-brightness" min="0.1" max="2.0" step="0.1" value="1.6">
            </div>

            <div class="filter-group" style="margin-top: 15px;">
                <label for="terrain-density-select">Wireframe Density</label>
                <select id="terrain-density-select">
                    <option value="16">Low (fast)</option>
                    <option value="32">Medium</option>
                    <option value="64" selected>High</option>
                    <option value="128">Very High</option>
                </select>
            </div>

            <div class="slider-group" style="margin-top: 10px;">
                <label>
                    <span style="font-size: 11px;">Color Hue</span>
                    <span id="terrain-hue-value" style="font-size: 11px;">0° (gray)</span>
                </label>
                <input type="range" id="terrain-hue" min="0" max="360" step="1" value="0">
            </div>

            <div class="slider-group" style="margin-top: 5px;">
                <label>
                    <span style="font-size: 11px;">Brightness</span>
                    <span id="terrain-brightness-value" style="font-size: 11px;">50%</span>
                </label>
                <input type="range" id="terrain-brightness" min="10" max="90" step="5" value="50">
            </div>

            <div class="checkbox-group" style="margin-top: 10px;">
                <input type="checkbox" id="elevation-gradient" checked>
                <label for="elevation-gradient">Elevation gradient</label>
            </div>

            <div class="slider-group" style="margin-left: 20px; margin-top: 5px;">
                <label>
                    <span style="font-size: 11px;">Gradient Intensity</span>
                    <span id="gradient-intensity-value" style="font-size: 11px;">2.6x</span>
                </label>
                <input type="range" id="gradient-intensity" min="0" max="4.0" step="0.1" value="2.6">
            </div>
        </div>
    </div>

    <div id="fly-instructions" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; display: none; z-index: 300; border: 2px solid #4CAF50; text-align: center;">
        <h2 style="margin: 0 0 15px 0; color: #4CAF50;">Fly Mode Controls</h2>
        <p style="margin: 10px 0;">W/A/S/D - Move forward/left/back/right</p>
        <p style="margin: 10px 0;">Space - Move up</p>
        <p style="margin: 10px 0;">Shift - Move down</p>
        <p style="margin: 10px 0;">Mouse - Look around</p>
        <p style="margin: 15px 0 0 0; color: #888; font-size: 12px;">Click anywhere to start flying</p>
    </div>

    <!-- TopoJSON library for lightweight vector boundaries -->
    <script src="https://unpkg.com/topojson-client@3"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        // Airport coordinates
        const airports = {
            // United States
            'JFK': { name: 'JFK - New York', lat: 40.6413, lon: -73.7781, elevation: 13, displayCode: 'JFK', city: 'New York' },
            'LAX': { name: 'LAX - Los Angeles', lat: 33.9416, lon: -118.4085, elevation: 125, displayCode: 'LAX', city: 'Los Angeles' },
            'ORD': { name: 'ORD - Chicago', lat: 41.9742, lon: -87.9073, elevation: 672, displayCode: 'ORD', city: 'Chicago' },
            'DFW': { name: 'DFW - Dallas/Fort Worth', lat: 32.8998, lon: -97.0403, elevation: 607, displayCode: 'DFW', city: 'Dallas' },
            'ATL': { name: 'ATL - Atlanta', lat: 33.6407, lon: -84.4277, elevation: 1026, displayCode: 'ATL', city: 'Atlanta' },
            'DEN': { name: 'DEN - Denver', lat: 39.8561, lon: -104.6737, elevation: 5434, displayCode: 'DIA', city: 'Denver' },
            'DSM': { name: 'DSM - Des Moines', lat: 41.5340, lon: -93.6631, elevation: 958, displayCode: 'DSM', city: 'Des Moines' },
            'SFO': { name: 'SFO - San Francisco', lat: 37.6213, lon: -122.3790, elevation: 13, displayCode: 'SFO', city: 'San Francisco' },
            'SEA': { name: 'SEA - Seattle', lat: 47.4502, lon: -122.3088, elevation: 433, displayCode: 'SEA', city: 'Seattle' },
            'MIA': { name: 'MIA - Miami', lat: 25.7959, lon: -80.2870, elevation: 8, displayCode: 'MIA', city: 'Miami' },
            'BOS': { name: 'BOS - Boston', lat: 42.3656, lon: -71.0096, elevation: 19, displayCode: 'BOS', city: 'Boston' },
            'LAS': { name: 'LAS - Las Vegas', lat: 36.0840, lon: -115.1537, elevation: 2181, displayCode: 'LAS', city: 'Las Vegas' },
            'PHX': { name: 'PHX - Phoenix', lat: 33.4352, lon: -112.0101, elevation: 1135, displayCode: 'PHX', city: 'Phoenix' },
            'IAH': { name: 'IAH - Houston', lat: 29.9902, lon: -95.3368, elevation: 97, displayCode: 'IAH', city: 'Houston' },
            'MSP': { name: 'MSP - Minneapolis', lat: 44.8848, lon: -93.2223, elevation: 841, displayCode: 'MSP', city: 'Minneapolis' },
            'DTW': { name: 'DTW - Detroit', lat: 42.2125, lon: -83.3534, elevation: 645, displayCode: 'DTW', city: 'Detroit' },
            'PHL': { name: 'PHL - Philadelphia', lat: 39.8744, lon: -75.2424, elevation: 36, displayCode: 'PHL', city: 'Philadelphia' },
            'CLT': { name: 'CLT - Charlotte', lat: 35.2140, lon: -80.9431, elevation: 748, displayCode: 'CLT', city: 'Charlotte' },
            'MCO': { name: 'MCO - Orlando', lat: 28.4294, lon: -81.3089, elevation: 96, displayCode: 'MCO', city: 'Orlando' },
            'PDX': { name: 'PDX - Portland', lat: 45.5887, lon: -122.5975, elevation: 31, displayCode: 'PDX', city: 'Portland' },
            'SLC': { name: 'SLC - Salt Lake City', lat: 40.7899, lon: -111.9791, elevation: 4227, displayCode: 'SLC', city: 'Salt Lake City' },
            'SAN': { name: 'SAN - San Diego', lat: 32.7338, lon: -117.1933, elevation: 17, displayCode: 'SAN', city: 'San Diego' },
            'SDF': { name: 'SDF - Louisville', lat: 38.1744, lon: -85.7364, elevation: 501, displayCode: 'SDF', city: 'Louisville' },
            'TPA': { name: 'TPA - Tampa', lat: 27.9755, lon: -82.5332, elevation: 26, displayCode: 'TPA', city: 'Tampa' },
            'AUS': { name: 'AUS - Austin', lat: 30.1945, lon: -97.6699, elevation: 542, displayCode: 'AUS', city: 'Austin' },
            'BNA': { name: 'BNA - Nashville', lat: 36.1245, lon: -86.6782, elevation: 599, displayCode: 'BNA', city: 'Nashville' },
            'STL': { name: 'STL - St. Louis', lat: 38.7487, lon: -90.3700, elevation: 618, displayCode: 'STL', city: 'St. Louis' },
            'BWI': { name: 'BWI - Baltimore', lat: 39.1754, lon: -76.6683, elevation: 146, displayCode: 'BWI', city: 'Baltimore' },
            'HNL': { name: 'HNL - Honolulu', lat: 21.3187, lon: -157.9225, elevation: 13, displayCode: 'HNL', city: 'Honolulu' },
            'PHNL': { name: 'PHNL - Honolulu International', lat: 21.3187, lon: -157.9225, elevation: 13, displayCode: 'PHNL', city: 'Honolulu' },
            'PHOG': { name: 'PHOG - Kahului (Maui)', lat: 20.8986, lon: -156.4305, elevation: 54, displayCode: 'OGG', city: 'Kahului' },
            'PHKO': { name: 'PHKO - Kona', lat: 19.7388, lon: -156.0456, elevation: 47, displayCode: 'KOA', city: 'Kona' },
            'PHTO': { name: 'PHTO - Hilo', lat: 19.7214, lon: -155.0481, elevation: 39, displayCode: 'ITO', city: 'Hilo' },
            'PHLI': { name: 'PHLI - Lihue (Kauai)', lat: 21.9760, lon: -159.3389, elevation: 153, displayCode: 'LIH', city: 'Lihue' },
            'ANC': { name: 'ANC - Anchorage', lat: 61.1743, lon: -149.9962, elevation: 152, displayCode: 'ANC', city: 'Anchorage' },
            'EWR': { name: 'EWR - Newark', lat: 40.6925, lon: -74.1687, elevation: 18, displayCode: 'EWR', city: 'Newark' },
            'LGA': { name: 'LGA - New York LaGuardia', lat: 40.7769, lon: -73.8740, elevation: 22, displayCode: 'LGA', city: 'New York' },
            'IAD': { name: 'IAD - Washington Dulles', lat: 38.9531, lon: -77.4565, elevation: 313, displayCode: 'IAD', city: 'Washington DC' },
            'DCA': { name: 'DCA - Reagan National', lat: 38.8521, lon: -77.0377, elevation: 15, displayCode: 'DCA', city: 'Washington DC' },
            'MDW': { name: 'MDW - Chicago Midway', lat: 41.7868, lon: -87.7522, elevation: 620, displayCode: 'MDW', city: 'Chicago' },
            'DAL': { name: 'DAL - Dallas Love Field', lat: 32.8470, lon: -96.8517, elevation: 487, displayCode: 'DAL', city: 'Dallas' },
            'HOU': { name: 'HOU - Houston Hobby', lat: 29.6454, lon: -95.2789, elevation: 46, displayCode: 'HOU', city: 'Houston' },
            'OAK': { name: 'OAK - Oakland', lat: 37.7213, lon: -122.2208, elevation: 9, displayCode: 'OAK', city: 'Oakland' },
            'SJC': { name: 'SJC - San Jose', lat: 37.3639, lon: -121.9289, elevation: 62, displayCode: 'SJC', city: 'San Jose' },
            'BUR': { name: 'BUR - Burbank', lat: 34.2007, lon: -118.3585, elevation: 778, displayCode: 'BUR', city: 'Burbank' },
            'ONT': { name: 'ONT - Ontario', lat: 34.0560, lon: -117.6012, elevation: 944, displayCode: 'ONT', city: 'Ontario' },
            'SNA': { name: 'SNA - Orange County', lat: 33.6757, lon: -117.8682, elevation: 56, displayCode: 'SNA', city: 'Santa Ana' },
            'SMF': { name: 'SMF - Sacramento', lat: 38.6954, lon: -121.5908, elevation: 27, displayCode: 'SMF', city: 'Sacramento' },
            'RNO': { name: 'RNO - Reno', lat: 39.4991, lon: -119.7681, elevation: 4415, displayCode: 'RNO', city: 'Reno' },
            'ABQ': { name: 'ABQ - Albuquerque', lat: 35.0402, lon: -106.6092, elevation: 5355, displayCode: 'ABQ', city: 'Albuquerque' },
            'ELP': { name: 'ELP - El Paso', lat: 31.8072, lon: -106.3778, elevation: 3958, displayCode: 'ELP', city: 'El Paso' },
            'TUS': { name: 'TUS - Tucson', lat: 32.1161, lon: -110.9410, elevation: 2643, displayCode: 'TUS', city: 'Tucson' },
            'SAT': { name: 'SAT - San Antonio', lat: 29.5337, lon: -98.4698, elevation: 809, displayCode: 'SAT', city: 'San Antonio' },
            'OKC': { name: 'OKC - Oklahoma City', lat: 35.3931, lon: -97.6007, elevation: 1295, displayCode: 'OKC', city: 'Oklahoma City' },
            'MCI': { name: 'MCI - Kansas City', lat: 39.2976, lon: -94.7139, elevation: 1026, displayCode: 'MCI', city: 'Kansas City' },
            'CVG': { name: 'CVG - Cincinnati', lat: 39.0488, lon: -84.6678, elevation: 896, displayCode: 'CVG', city: 'Cincinnati' },
            'CLE': { name: 'CLE - Cleveland', lat: 41.4117, lon: -81.8498, elevation: 791, displayCode: 'CLE', city: 'Cleveland' },
            'PIT': { name: 'PIT - Pittsburgh', lat: 40.4915, lon: -80.2329, elevation: 1203, displayCode: 'PIT', city: 'Pittsburgh' },
            'BDL': { name: 'BDL - Hartford', lat: 41.9389, lon: -72.6832, elevation: 173, displayCode: 'BDL', city: 'Hartford' },
            'PVD': { name: 'PVD - Providence', lat: 41.7240, lon: -71.4281, elevation: 55, displayCode: 'PVD', city: 'Providence' },
            'RDU': { name: 'RDU - Raleigh-Durham', lat: 35.8776, lon: -78.7875, elevation: 435, displayCode: 'RDU', city: 'Raleigh' },
            'JAX': { name: 'JAX - Jacksonville', lat: 30.4941, lon: -81.6879, elevation: 30, displayCode: 'JAX', city: 'Jacksonville' },
            'RSW': { name: 'RSW - Fort Myers', lat: 26.5362, lon: -81.7552, elevation: 30, displayCode: 'RSW', city: 'Fort Myers' },
            'PBI': { name: 'PBI - West Palm Beach', lat: 26.6832, lon: -80.0956, elevation: 19, displayCode: 'PBI', city: 'West Palm Beach' },
            'FLL': { name: 'FLL - Fort Lauderdale', lat: 26.0726, lon: -80.1527, elevation: 9, displayCode: 'FLL', city: 'Fort Lauderdale' },
            'MEM': { name: 'MEM - Memphis', lat: 35.0424, lon: -89.9767, elevation: 341, displayCode: 'MEM', city: 'Memphis' },
            'IND': { name: 'IND - Indianapolis', lat: 39.7173, lon: -86.2944, elevation: 797, displayCode: 'IND', city: 'Indianapolis' },
            'CMH': { name: 'CMH - Columbus', lat: 39.9980, lon: -82.8919, elevation: 815, displayCode: 'CMH', city: 'Columbus' },
            'MKE': { name: 'MKE - Milwaukee', lat: 42.9472, lon: -87.8966, elevation: 723, displayCode: 'MKE', city: 'Milwaukee' },
            'MSY': { name: 'MSY - New Orleans', lat: 29.9934, lon: -90.2580, elevation: 4, displayCode: 'MSY', city: 'New Orleans' },
            'LAN': { name: 'LAN - Lansing', lat: 42.7787, lon: -84.5874, elevation: 861, displayCode: 'LAN', city: 'Lansing' },
            // Europe
            'LHR': { name: 'LHR - London Heathrow', lat: 51.4700, lon: -0.4543, elevation: 83 },
            'CDG': { name: 'CDG - Paris', lat: 49.0097, lon: 2.5479, elevation: 392 },
            'FRA': { name: 'FRA - Frankfurt', lat: 50.0379, lon: 8.5622, elevation: 364 },
            'AMS': { name: 'AMS - Amsterdam', lat: 52.3105, lon: 4.7683, elevation: -11 },
            'MAD': { name: 'MAD - Madrid', lat: 40.4983, lon: -3.5676, elevation: 2001 },
            'MAN': { name: 'MAN - Manchester', lat: 53.3537, lon: -2.2750, elevation: 257 },
            'FCO': { name: 'FCO - Rome', lat: 41.8003, lon: 12.2389, elevation: 13 },
            'BCN': { name: 'BCN - Barcelona', lat: 41.2971, lon: 2.0785, elevation: 12 },
            'BOH': { name: 'BOH - Bournemouth', lat: 50.7800, lon: -1.8425, elevation: 38 },
            'MUC': { name: 'MUC - Munich', lat: 48.3538, lon: 11.7861, elevation: 1487 },
            'LGW': { name: 'LGW - London Gatwick', lat: 51.1537, lon: -0.1821, elevation: 202 },
            'IST': { name: 'IST - Istanbul', lat: 41.2753, lon: 28.7519, elevation: 325 },
            'ZRH': { name: 'ZRH - Zurich', lat: 47.4647, lon: 8.5492, elevation: 1416 },
            'CPH': { name: 'CPH - Copenhagen', lat: 55.6180, lon: 12.6508, elevation: 17 },
            'OSL': { name: 'OSL - Oslo', lat: 60.1939, lon: 11.1004, elevation: 681 },
            'ARN': { name: 'ARN - Stockholm', lat: 59.6519, lon: 17.9186, elevation: 137 },
            'VIE': { name: 'VIE - Vienna', lat: 48.1103, lon: 16.5697, elevation: 600 },
            'BRU': { name: 'BRU - Brussels', lat: 50.9014, lon: 4.4844, elevation: 184 },
            'DUB': { name: 'DUB - Dublin', lat: 53.4213, lon: -6.2701, elevation: 242 },
            'EDI': { name: 'EDI - Edinburgh', lat: 55.9500, lon: -3.3725, elevation: 135 },
            'LIS': { name: 'LIS - Lisbon', lat: 38.7813, lon: -9.1359, elevation: 374 },
            'ATH': { name: 'ATH - Athens', lat: 37.9364, lon: 23.9445, elevation: 308 },
            'PRG': { name: 'PRG - Prague', lat: 50.1008, lon: 14.2632, elevation: 1247 },
            'HEL': { name: 'HEL - Helsinki', lat: 60.3172, lon: 24.9633, elevation: 171 },
            'RTM': { name: 'RTM - Rotterdam', lat: 51.9569, lon: 4.4375, elevation: -15 },
            'EIN': { name: 'EIN - Eindhoven', lat: 51.4500, lon: 5.3747, elevation: 74 },
            'BUD': { name: 'BUD - Budapest', lat: 47.4297, lon: 19.2611, elevation: 495 },
            // Middle East
            'DXB': { name: 'DXB - Dubai', lat: 25.2532, lon: 55.3657, elevation: 62 },
            'DOH': { name: 'DOH - Doha', lat: 25.2731, lon: 51.6081, elevation: 35 },
            'AUH': { name: 'AUH - Abu Dhabi', lat: 24.4330, lon: 54.6511, elevation: 88 },
            'TLV': { name: 'TLV - Tel Aviv', lat: 32.0114, lon: 34.8867, elevation: 135 },
            'CAI': { name: 'CAI - Cairo', lat: 30.1219, lon: 31.4056, elevation: 382 },
            // Asia
            'SIN': { name: 'SIN - Singapore', lat: 1.3644, lon: 103.9915, elevation: 22 },
            'HKG': { name: 'HKG - Hong Kong', lat: 22.3080, lon: 113.9185, elevation: 28 },
            'NRT': { name: 'NRT - Tokyo Narita', lat: 35.7720, lon: 140.3929, elevation: 141 },
            'HND': { name: 'HND - Tokyo Haneda', lat: 35.5494, lon: 139.7798, elevation: 35 },
            'PEK': { name: 'PEK - Beijing', lat: 40.0799, lon: 116.6031, elevation: 116 },
            'PVG': { name: 'PVG - Shanghai', lat: 31.1443, lon: 121.8083, elevation: 13 },
            'ICN': { name: 'ICN - Seoul', lat: 37.4691, lon: 126.4505, elevation: 23 },
            'BKK': { name: 'BKK - Bangkok', lat: 13.6900, lon: 100.7501, elevation: 5 },
            'KUL': { name: 'KUL - Kuala Lumpur', lat: 2.7456, lon: 101.7099, elevation: 69 },
            'DEL': { name: 'DEL - New Delhi', lat: 28.5665, lon: 77.1031, elevation: 777 },
            'BOM': { name: 'BOM - Mumbai', lat: 19.0896, lon: 72.8656, elevation: 39 },
            'CGK': { name: 'CGK - Jakarta', lat: -6.1256, lon: 106.6559, elevation: 34 },
            'MNL': { name: 'MNL - Manila', lat: 14.5086, lon: 121.0194, elevation: 75 },
            'TPE': { name: 'TPE - Taipei', lat: 25.0777, lon: 121.2328, elevation: 106 },
            // Oceania
            'SYD': { name: 'SYD - Sydney', lat: -33.9399, lon: 151.1753, elevation: 21 },
            'MEL': { name: 'MEL - Melbourne', lat: -37.6690, lon: 144.8410, elevation: 434 },
            'BNE': { name: 'BNE - Brisbane', lat: -27.3842, lon: 153.1175, elevation: 13 },
            'PER': { name: 'PER - Perth', lat: -31.9403, lon: 115.9672, elevation: 67 },
            'AKL': { name: 'AKL - Auckland', lat: -37.0082, lon: 174.7850, elevation: 23 },
            'WLG': { name: 'WLG - Wellington', lat: -41.3272, lon: 174.8050, elevation: 42 },
            // Canada
            'YYZ': { name: 'YYZ - Toronto', lat: 43.6777, lon: -79.6248, elevation: 569 },
            'YVR': { name: 'YVR - Vancouver', lat: 49.1939, lon: -123.1844, elevation: 14 },
            'YUL': { name: 'YUL - Montreal', lat: 45.4706, lon: -73.7408, elevation: 118 },
            'YYC': { name: 'YYC - Calgary', lat: 51.1315, lon: -114.0106, elevation: 3557 },
            // Latin America
            'MEX': { name: 'MEX - Mexico City', lat: 19.4363, lon: -99.0721, elevation: 7316 },
            'GRU': { name: 'GRU - São Paulo', lat: -23.4356, lon: -46.4731, elevation: 2459 },
            'GIG': { name: 'GIG - Rio de Janeiro', lat: -22.8099, lon: -43.2505, elevation: 30 },
            'BOG': { name: 'BOG - Bogotá', lat: 4.7016, lon: -74.1469, elevation: 8361 },
            'LIM': { name: 'LIM - Lima', lat: -12.0219, lon: -77.1143, elevation: 113 },
            'SCL': { name: 'SCL - Santiago', lat: -33.3930, lon: -70.7859, elevation: 1555 },
            'EZE': { name: 'EZE - Buenos Aires', lat: -34.8222, lon: -58.5358, elevation: 67 },
            'CUN': { name: 'CUN - Cancún', lat: 21.0365, lon: -86.8771, elevation: 22 },
            // Africa
            'JNB': { name: 'JNB - Johannesburg', lat: -26.1392, lon: 28.2460, elevation: 5558 },
            'CPT': { name: 'CPT - Cape Town', lat: -33.9715, lon: 18.6021, elevation: 151 },
            'NBO': { name: 'NBO - Nairobi', lat: -1.3192, lon: 36.9278, elevation: 5327 },
            'ADD': { name: 'ADD - Addis Ababa', lat: 8.9779, lon: 38.7991, elevation: 7625 }
        };

        // Configuration
        const config = {
            updateInterval: 1000, // 1 second
            maxTrailLength: 1000,
            altitudeScale: 1.2, // Scale altitude for better visualization
            floorHeight: 0, // Adjustable floor height
            radius: 100, // km radius for aircraft search
            centerLat: 40.0, // Default to center US
            centerLon: -105.0,
            elevation: 0, // User's ground elevation
            lineThickness: 2, // Trail line thickness
            // Terrain color/gradient settings
            terrainColorHue: 0, // 0 = gray, 0-360 = color spectrum
            terrainBrightness: 50, // 10-90, percentage
            elevationGradient: true, // Enable elevation gradient effect
            gradientIntensity: 2.6 // 0-4.0, multiplier for gradient strength
        };

        // Filters
        const filters = {
            callsign: '',
            type: '',
            altitudeMin: null,
            altitudeMax: 100000,
            showGround: true,
            removeMode: false // If true, remove aircraft; if false, just hide them
        };


        // State
        const aircraftData = new Map(); // hex -> { positions: [], lastUpdate: timestamp, info: {} }

        // Batched LOD update variables for performance optimization
        let lodUpdateOffset = 0;
        const LOD_UPDATE_PERCENTAGE = 0.15; // Update 15% of aircraft per frame

        let scene, camera, renderer, controls;
        let trailGroup, aircraftGroup, gridHelper, axesHelper;

        // Aircraft 3D model geometries for different types
        let aircraftGeometries = {};

        // Circular texture for aircraft glow halos
        let glowCircleTexture = null;

        let mapPlane = null; // Legacy - will be removed
        let currentMapLayer = 'dark'; // 'none', 'dark', or 'dark-nolabels'
        let mapLoadingToken = 0; // Token to track the most recent map load request
        let mapBrightness = 1.6; // Map tile brightness multiplier (0.1 - 2.0)

        // TILE STREAMING SYSTEM - Frustum-based culling (camera-view only)
        const loadedTiles = new Map(); // tileKey → {mesh, material, texture, x, y, zoom, lat, lon}
        const tileLoadQueue = []; // Queue of tiles to load
        let tilesGroup = null; // Group to hold all tile meshes
        const MAX_LOADED_TILES = 4000; // Maximum tiles in memory (wider aperture needs more tiles)

        // TERRAIN SYSTEM - 3D elevation mesh
        const loadedTerrainTiles = new Map(); // tileKey → {mesh, material, geometry, elevationData}
        let terrainGroup = null; // Group to hold terrain meshes
        let terrainEnabled = true; // Toggle terrain on/off (controlled by map layer selection)
        let terrainExaggeration = 1.0; // Elevation multiplier (1.0 = true scale)
        let terrainTextureMode = 'map'; // 'wireframe', 'map', or 'satellite' (used when terrain enabled)
        let terrainSegmentDensity = 64; // Subdivisions for terrain mesh (adjustable for wireframe)

        // Global elevation tracking for consistent gradient across all tiles
        let globalMinElev = Infinity;
        let globalMaxElev = -Infinity;
        const TERRAIN_TILE_SIZE_KM = 39.1; // Fixed tile size at zoom 10 (prevents gaps)

        // VECTOR BOUNDARY SYSTEM - Lightweight alternative to tiles
        let boundariesGroup = null; // Group to hold vector boundary lines
        let boundariesLoaded = false; // Track if boundaries have been loaded
        let showBoundaries = true; // Toggle boundary visibility
        let boundaryResolution = '110m'; // '110m' (global), '50m' (regional), '10m' (detailed)

        // FOCUSED TILES MODE - Only show tiles within search radius
        let focusedTilesMode = true; // When enabled, restricts tiles to config.radius

        // Detect mobile devices for performance optimization
        const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                               ('ontouchstart' in window) ||
                               (navigator.maxTouchPoints > 0);

        console.log(`📱 Device type: ${isMobileDevice ? 'Mobile' : 'Desktop'}`);

        // Camera-based tile loading state
        let lastCameraPosition = new THREE.Vector3();
        let lastViewCenter = { lat: 0, lon: 0 }; // Track view center for pan detection
        let lastVisibleRadius = 0; // Track zoom level changes

        // Mobile-adaptive thresholds (less aggressive on mobile)
        const VIEW_CENTER_MOVE_THRESHOLD = isMobileDevice ? 20 : 10; // Retile when view center moves (mobile: 20km, desktop: 10km)
        const VISIBLE_RADIUS_CHANGE_THRESHOLD = isMobileDevice ? 0.3 : 0.2; // Retile when zoom changes (mobile: 30%, desktop: 20%)
        const RETILE_DEBOUNCE_MS = isMobileDevice ? 500 : 200; // Wait after camera stops moving before retiling
        const MIN_RETILE_INTERVAL_MS = isMobileDevice ? 1500 : 500; // Minimum time between retiles

        // Retiling state
        let retileDebounceTimer = null;
        let lastRetileTime = 0;
        let pendingRetile = false;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const clickableObjects = [];
        let updateIntervalId = null;
        let activeLabel = null; // Track which label is currently shown
        let expandedLabel = null; // Track which label is currently expanded

        // Recording/Playback State
        let isRecording = false;
        let isPlayingBack = false;
        let recordingData = null;
        let recordingStartTime = null;
        let playbackData = null;
        let playbackStartTime = null;
        let playbackCurrentTime = 0;
        let playbackSpeed = 1.0;
        let playbackPaused = false;
        let playbackIntervalId = null;
        const maxRecordingDuration = 360 * 60 * 1000; // 360 minutes (6 hours) max
        const recordingInterval = 1000; // Record every 1 second (same as update rate)

        // Aircraft following state
        let followedAircraftHex = null;
        let followModeEnabled = true;
        let surfModeEnabled = false; // Auto-switch to next aircraft when current is lost
        let surfModeWaitingForAircraft = false; // Flag to prevent immediate selection after airport jump
        let surfModeAirportJumpTime = 0; // Timestamp of last airport jump
        const SURF_MODE_AIRPORT_DELAY = 5000; // Wait 5 seconds for aircraft to load after airport jump
        let surfModeAircraftLostTime = 0; // Timestamp when aircraft was lost
        let surfModeLastFollowedHex = null; // Track last followed aircraft to try reconnecting
        const SURF_MODE_LOST_GRACE_PERIOD = 5000; // Wait 5 seconds after losing aircraft before switching
        let lastFollowSearchLat = null;
        let lastFollowSearchLon = null;
        let followSearchLat = null;
        let followSearchLon = null;

        // Progressive map loading for flight following
        let lastMapCenterLat = null; // Track where map was last loaded
        let lastMapCenterLon = null;
        const mapUpdateThresholdPercent = 0.10; // Reload map when aircraft moves 10% of search radius

        // Fly mode state
        let orbitControls, flyControls;
        let isFlyMode = false;
        const moveSpeed = 0.5;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const keyboard = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false
        };

        // Auto-rotate state
        let autoRotateEnabled = true;
        let idleTimer = null;
        const idleTimeout = 10000; // 10 seconds

        // Airport label state
        let airportLabelEnabled = true; // Default to showing airport label
        let currentAirportLabel = null;
        let currentAirportCode = null;
        let fontLoader = null;
        let loadedFont = null;
        let labelShowFullName = true; // Default to city name
        let labelStanding = true; // Default to standing orientation
        let brandingLabel = null;

        // Color mode state
        let colorMode = 'altitude'; // 'altitude' or 'speed'

        // Compass state
        let compassEnabled = false;

        // Airspace state
        let airspaceEnabled = false;
        let airspaceOpacity = 0.3;
        let showClassB = true;
        let showClassC = true;
        let showClassD = true;
        let airspaceFocusOnly = true;
        let airspaceWireframeOnly = false;
        let airspaceGroup = null;
        let airspaceData = [];
        let lastAirspaceUpdate = 0;
        const AIRSPACE_UPDATE_INTERVAL = 300000; // Update every 5 minutes

        // Pastel colors for airspace classes
        const airspaceColors = {
            'B': 0xB4A7D6,  // Pastel purple
            'C': 0xFFB3BA,  // Pastel pink
            'D': 0xBAE1FF,  // Pastel blue
            'E': 0xC7CEEA   // Pastel lavender
        };

        // Helper to merge group into single geometry
        function mergeGroupToGeometry(group) {
            const geometries = [];
            group.updateMatrixWorld(true);
            group.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    const geom = child.geometry.clone();
                    geom.applyMatrix4(child.matrixWorld);
                    geometries.push(geom);
                }
            });

            // Merge all geometries
            const mergedGeom = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            let indexOffset = 0;

            geometries.forEach(geom => {
                const pos = geom.attributes.position.array;
                for (let i = 0; i < pos.length; i++) {
                    vertices.push(pos[i]);
                }

                if (geom.index) {
                    const idx = geom.index.array;
                    for (let i = 0; i < idx.length; i++) {
                        indices.push(idx[i] + indexOffset);
                    }
                    indexOffset += pos.length / 3;
                }
            });

            mergedGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            mergedGeom.setIndex(indices);
            mergedGeom.computeVertexNormals();
            return mergedGeom;
        }

        // Create circular sprite texture for aircraft glow halos
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Create radial gradient from center
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');     // Bright center
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)'); // Mid-bright
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)'); // Fade
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');     // Transparent edge

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Create low-poly aircraft geometries for different aircraft types
        function createAircraftGeometries() {
            // Commercial Jet (A320, B737, etc.) - Low-poly fuselage with wings
            aircraftGeometries.commercial = createCommercialJetGeometry();

            // Private Jet / Business Jet - Smaller, sleeker
            aircraftGeometries.private = createPrivateJetGeometry();

            // Single Engine Prop Plane - Small aircraft
            aircraftGeometries.singleEngine = createSingleEngineGeometry();

            // Multi Engine Prop Plane - Twin engine
            aircraftGeometries.multiEngine = createMultiEngineGeometry();

            // Helicopter - Distinctive rotor blades
            aircraftGeometries.helicopter = createHelicopterGeometry();

            // Balloon / Lighter-than-air
            aircraftGeometries.balloon = createBalloonGeometry();

            // Heavy Aircraft (B747, A380, etc.) - Larger version
            aircraftGeometries.heavy = createHeavyJetGeometry();

            // Glider - Long, thin wings
            aircraftGeometries.glider = createGliderGeometry();

            console.log('✈️ Aircraft 3D models created');
            console.log('🎯 LOD (Level of Detail) system enabled:');
            console.log('   • Aircraft: 4 detail levels (0-100, 100-300, 300-700, 700+ units)');
            console.log('   • Terrain: Dynamic segments (64→32→16→8 based on distance)');
            console.log('   • Trails: Adaptive points (200→75→30→15 based on distance)');
            console.log('   • Glows: Optimized sprites (replacing sphere meshes)');
            console.log('   Expected: 50-100% FPS improvement or 2-3x capacity');
        }

        // Commercial Jet Geometry - Boeing 737 style
        function createCommercialJetGeometry() {
            const group = new THREE.Group();
            const dummyMat = new THREE.MeshBasicMaterial();

            // Fuselage (rounded cylinder) - main body
            const fuselage = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.0, 12), dummyMat);
            fuselage.rotation.x = Math.PI / 2;
            fuselage.position.z = 0;
            group.add(fuselage);

            // Rounded nose cone (hemisphere integrated into fuselage)
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2), dummyMat);
            nose.scale.set(1, 1.2, 1);
            nose.rotation.x = Math.PI / 2;
            nose.position.z = 0.5;
            group.add(nose);

            // Tail cone (tapered)
            const tailCone = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.01, 0.25, 12), dummyMat);
            tailCone.rotation.x = Math.PI / 2;
            tailCone.position.z = -0.625;
            group.add(tailCone);

            // Swept wings (tapered)
            const wingGeometry = new THREE.BufferGeometry();
            const wingVertices = new Float32Array([
                -0.9, -0.03, -0.1,   -0.05, -0.03, 0.05,
                -0.05, -0.03, -0.2,  -0.9, -0.03, -0.2,
                -0.9, 0.01, -0.1,    -0.05, 0.01, 0.05,
                -0.05, 0.01, -0.2,   -0.9, 0.01, -0.2
            ]);
            const wingIndices = [0,1,2, 0,2,3, 4,6,5, 4,7,6, 0,4,5, 0,5,1, 2,6,7, 2,7,3, 0,3,7, 0,7,4, 1,5,6, 1,6,2];
            wingGeometry.setAttribute('position', new THREE.BufferAttribute(wingVertices, 3));
            wingGeometry.setIndex(wingIndices);
            wingGeometry.computeVertexNormals();

            const leftWing = new THREE.Mesh(wingGeometry, dummyMat);
            group.add(leftWing);
            const rightWing = leftWing.clone();
            rightWing.scale.x = -1;
            group.add(rightWing);

            // Swept vertical tail
            const vtailGeom = new THREE.BufferGeometry();
            const vtailVerts = new Float32Array([
                -0.01, 0, -0.5,    0.01, 0, -0.5,
                -0.01, 0.3, -0.65, 0.01, 0.3, -0.65,
                -0.01, 0, -0.7,    0.01, 0, -0.7,
                -0.01, 0.3, -0.85, 0.01, 0.3, -0.85
            ]);
            const vtailIndices = [0,2,1, 1,2,3, 4,5,6, 5,7,6, 0,1,4, 1,5,4, 2,6,3, 3,6,7, 0,4,2, 2,4,6, 1,3,5, 3,7,5];
            vtailGeom.setAttribute('position', new THREE.BufferAttribute(vtailVerts, 3));
            vtailGeom.setIndex(vtailIndices);
            vtailGeom.computeVertexNormals();
            const vtail = new THREE.Mesh(vtailGeom, dummyMat);
            group.add(vtail);

            // Horizontal tail
            const htail = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.02, 0.15), dummyMat);
            htail.position.set(0, 0.02, -0.68);
            group.add(htail);

            // Engine nacelles with pylons
            const createEngine = (x) => {
                const engineGroup = new THREE.Group();
                const cowl = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.18, 12), dummyMat);
                cowl.rotation.x = Math.PI / 2;
                engineGroup.add(cowl);

                const intake = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.05, 0.03, 12), dummyMat);
                intake.rotation.x = Math.PI / 2;
                intake.position.z = 0.105;
                engineGroup.add(intake);

                const pylon = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.02), dummyMat);
                pylon.position.set(0, 0.03, 0);
                engineGroup.add(pylon);

                engineGroup.position.set(x, -0.1, -0.05);
                return engineGroup;
            };

            group.add(createEngine(-0.45));
            group.add(createEngine(0.45));

            return mergeGroupToGeometry(group);
        }

        // Private Jet Geometry - Learjet style with T-tail
        function createPrivateJetGeometry() {
            const group = new THREE.Group();
            const dummyMat = new THREE.MeshBasicMaterial();

            // Fuselage (sleek, tapered)
            const fuselage = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.055, 0.9, 12), dummyMat);
            fuselage.rotation.x = Math.PI / 2;
            fuselage.position.z = 0;
            group.add(fuselage);

            // Pointed nose cone
            const nose = new THREE.Mesh(new THREE.CylinderGeometry(0, 0.06, 0.15, 12), dummyMat);
            nose.rotation.x = Math.PI / 2;
            nose.position.z = 0.525;
            group.add(nose);

            // Tail section (tapered)
            const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.03, 0.2, 12), dummyMat);
            tail.rotation.x = Math.PI / 2;
            tail.position.z = -0.55;
            group.add(tail);

            // Swept wings (low-mounted, tapered)
            const wingGeometry = new THREE.BufferGeometry();
            const wingVerts = new Float32Array([
                -0.6, -0.03, -0.08, -0.05, -0.03, 0.12,
                -0.05, -0.03, -0.12, -0.6, -0.03, -0.18,
                -0.6, -0.01, -0.08, -0.05, -0.01, 0.12,
                -0.05, -0.01, -0.12, -0.6, -0.01, -0.18
            ]);
            const wingIndices = [0,1,2,0,2,3, 4,6,5,4,7,6, 0,4,5,0,5,1, 2,6,7,2,7,3, 0,3,7,0,7,4, 1,5,6,1,6,2];
            wingGeometry.setAttribute('position', new THREE.BufferAttribute(wingVerts, 3));
            wingGeometry.setIndex(wingIndices);
            wingGeometry.computeVertexNormals();

            const leftWing = new THREE.Mesh(wingGeometry, dummyMat);
            group.add(leftWing);
            const rightWing = leftWing.clone();
            rightWing.scale.x = -1;
            group.add(rightWing);

            // Swept vertical tail (tall T-tail)
            const vtailGeom = new THREE.BufferGeometry();
            const vtailVerts = new Float32Array([
                -0.01, 0, -0.45,   0.01, 0, -0.45,
                -0.01, 0.35, -0.6, 0.01, 0.35, -0.6,
                -0.01, 0, -0.55,   0.01, 0, -0.55,
                -0.01, 0.35, -0.7, 0.01, 0.35, -0.7
            ]);
            const vtailIndices = [0,2,1, 1,2,3, 4,5,6, 5,7,6, 0,1,4, 1,5,4, 2,6,3, 3,6,7, 0,4,2, 2,4,6, 1,3,5, 3,7,5];
            vtailGeom.setAttribute('position', new THREE.BufferAttribute(vtailVerts, 3));
            vtailGeom.setIndex(vtailIndices);
            vtailGeom.computeVertexNormals();
            const vtail = new THREE.Mesh(vtailGeom, dummyMat);
            group.add(vtail);

            // T-tail (horizontal stabilizer on top)
            const ttail = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.02, 0.14), dummyMat);
            ttail.position.set(0, 0.35, -0.58);
            group.add(ttail);

            // Rear-mounted engines
            const createEngine = (x) => {
                const engineGroup = new THREE.Group();
                const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.04, 0.16, 12), dummyMat);
                engine.rotation.x = Math.PI / 2;
                engineGroup.add(engine);

                const intake = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.045, 0.03, 12), dummyMat);
                intake.rotation.x = Math.PI / 2;
                intake.position.z = 0.095;
                engineGroup.add(intake);

                engineGroup.position.set(x, 0.02, -0.4);
                return engineGroup;
            };

            group.add(createEngine(-0.12));
            group.add(createEngine(0.12));

            return mergeGroupToGeometry(group);
        }

        // Single Engine Prop Plane - Cessna 172 style
        function createSingleEngineGeometry() {
            const bodyGroup = new THREE.Group();
            const propGroup = new THREE.Group();
            const dummyMat = new THREE.MeshBasicMaterial();

            // Main fuselage (boxy, rectangular)
            const fuselage = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.13, 0.75), dummyMat);
            fuselage.position.z = 0;
            bodyGroup.add(fuselage);

            // Engine cowling
            const cowling = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.065, 0.15, 12), dummyMat);
            cowling.rotation.x = Math.PI / 2;
            cowling.position.z = 0.45;
            bodyGroup.add(cowling);

            // Propeller spinner cone
            const spinner = new THREE.Mesh(new THREE.CylinderGeometry(0, 0.035, 0.08, 12), dummyMat);
            spinner.rotation.x = Math.PI / 2;
            spinner.position.z = 0.56;
            bodyGroup.add(spinner);

            // Tail cone (tapered)
            const tailCone = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.025, 0.2, 8), dummyMat);
            tailCone.rotation.x = Math.PI / 2;
            tailCone.position.z = -0.475;
            bodyGroup.add(tailCone);

            // High-mounted rectangular wings
            const wings = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.03, 0.32), dummyMat);
            wings.position.set(0, 0.095, 0.02);
            bodyGroup.add(wings);

            // Wing struts
            const createStrut = (x, z) => {
                const strut = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.13, 6), dummyMat);
                strut.rotation.z = x < 0 ? 0.3 : -0.3;
                strut.position.set(x, 0.03, z);
                return strut;
            };
            bodyGroup.add(createStrut(-0.45, 0.08));
            bodyGroup.add(createStrut(-0.45, -0.08));
            bodyGroup.add(createStrut(0.45, 0.08));
            bodyGroup.add(createStrut(0.45, -0.08));

            // Swept vertical stabilizer
            const vtailGeom = new THREE.BufferGeometry();
            const vtailVerts = new Float32Array([
                -0.01, 0, -0.42,   0.01, 0, -0.42,
                -0.01, 0.25, -0.57, 0.01, 0.25, -0.57,
                -0.01, 0, -0.52,   0.01, 0, -0.52,
                -0.01, 0.25, -0.67, 0.01, 0.25, -0.67
            ]);
            const vtailIndices = [0,2,1, 1,2,3, 4,5,6, 5,7,6, 0,1,4, 1,5,4, 2,6,3, 3,6,7, 0,4,2, 2,4,6, 1,3,5, 3,7,5];
            vtailGeom.setAttribute('position', new THREE.BufferAttribute(vtailVerts, 3));
            vtailGeom.setIndex(vtailIndices);
            vtailGeom.computeVertexNormals();
            const vtail = new THREE.Mesh(vtailGeom, dummyMat);
            bodyGroup.add(vtail);

            // Horizontal stabilizer
            const htail = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.02, 0.15), dummyMat);
            htail.position.set(0, 0.035, -0.59);
            bodyGroup.add(htail);

            // Landing gear wheels
            const wheelGeom = new THREE.CylinderGeometry(0.035, 0.035, 0.025, 8);
            wheelGeom.rotateX(Math.PI / 2);

            const leftWheel = new THREE.Mesh(wheelGeom, dummyMat);
            leftWheel.position.set(-0.12, -0.1, 0);
            bodyGroup.add(leftWheel);

            const rightWheel = leftWheel.clone();
            rightWheel.position.x = 0.12;
            bodyGroup.add(rightWheel);

            const leftGearStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.11, 6), dummyMat);
            leftGearStrut.position.set(-0.12, -0.045, 0);
            bodyGroup.add(leftGearStrut);

            const rightGearStrut = leftGearStrut.clone();
            rightGearStrut.position.x = 0.12;
            bodyGroup.add(rightGearStrut);

            const noseWheel = new THREE.Mesh(wheelGeom, dummyMat);
            noseWheel.position.set(0, -0.1, 0.35);
            bodyGroup.add(noseWheel);

            const noseGearStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.11, 6), dummyMat);
            noseGearStrut.position.set(0, -0.045, 0.35);
            bodyGroup.add(noseGearStrut);

            // Two-blade propeller - separate from body
            const prop = new THREE.Mesh(new THREE.CircleGeometry(0.18, 16), dummyMat);
            prop.position.z = 0.6;
            propGroup.add(prop);

            return {
                body: mergeGroupToGeometry(bodyGroup),
                props: mergeGroupToGeometry(propGroup)
            };
        }

        // Multi Engine - Twin engine with prop discs
        function createMultiEngineGeometry() {
            const bodyGroup = new THREE.Group();
            const propGroup = new THREE.Group();
            const dummyMat = new THREE.MeshBasicMaterial();

            // Fuselage (main body)
            const fuselage = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.065, 1.0, 12), dummyMat);
            fuselage.rotation.x = Math.PI / 2;
            fuselage.position.z = 0;
            bodyGroup.add(fuselage);

            // Nose cone
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 12), dummyMat);
            nose.scale.set(1, 1, 0.8);
            nose.position.z = 0.54;
            bodyGroup.add(nose);

            // Tail cone (tapered)
            const tailCone = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.025, 0.18, 8), dummyMat);
            tailCone.rotation.x = Math.PI / 2;
            tailCone.position.z = -0.59;
            bodyGroup.add(tailCone);

            // Low wings
            const wings = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.025, 0.38), dummyMat);
            wings.position.set(0, -0.02, 0.15);
            bodyGroup.add(wings);

            // Swept vertical tail
            const vtailGeom = new THREE.BufferGeometry();
            const vtailVerts = new Float32Array([
                -0.01, 0, -0.54,   0.01, 0, -0.54,
                -0.01, 0.28, -0.67, 0.01, 0.28, -0.67,
                -0.01, 0, -0.64,   0.01, 0, -0.64,
                -0.01, 0.28, -0.77, 0.01, 0.28, -0.77
            ]);
            const vtailIndices = [0,2,1, 1,2,3, 4,5,6, 5,7,6, 0,1,4, 1,5,4, 2,6,3, 3,6,7, 0,4,2, 2,4,6, 1,3,5, 3,7,5];
            vtailGeom.setAttribute('position', new THREE.BufferAttribute(vtailVerts, 3));
            vtailGeom.setIndex(vtailIndices);
            vtailGeom.computeVertexNormals();
            const vtail = new THREE.Mesh(vtailGeom, dummyMat);
            bodyGroup.add(vtail);

            // Horizontal tail
            const htail = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.02, 0.15), dummyMat);
            htail.position.set(0, 0.03, -0.64);
            bodyGroup.add(htail);

            // Engine nacelles with cowlings
            const createEngine = (x) => {
                const engineGroup = new THREE.Group();
                const cowling = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.055, 0.22, 12), dummyMat);
                cowling.rotation.x = Math.PI / 2;
                engineGroup.add(cowling);

                const intake = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.06), dummyMat);
                intake.position.set(0, -0.05, 0.08);
                engineGroup.add(intake);

                const exhaust = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.03, 6), dummyMat);
                exhaust.rotation.x = Math.PI / 2;
                exhaust.position.z = -0.13;
                engineGroup.add(exhaust);

                engineGroup.position.set(x, -0.05, 0.25);
                return engineGroup;
            };

            bodyGroup.add(createEngine(-0.55));
            bodyGroup.add(createEngine(0.55));

            // Propeller spinners
            const leftSpinner = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 8), dummyMat);
            leftSpinner.scale.set(1, 1, 1.5);
            leftSpinner.position.set(-0.55, -0.05, 0.36);
            bodyGroup.add(leftSpinner);

            const rightSpinner = leftSpinner.clone();
            rightSpinner.position.x = 0.55;
            bodyGroup.add(rightSpinner);

            // Landing gear wheels
            const wheelGeom = new THREE.CylinderGeometry(0.035, 0.035, 0.025, 8);
            wheelGeom.rotateX(Math.PI / 2);

            const leftWheel = new THREE.Mesh(wheelGeom, dummyMat);
            leftWheel.position.set(-0.2, -0.09, 0.1);
            bodyGroup.add(leftWheel);

            const rightWheel = leftWheel.clone();
            rightWheel.position.x = 0.2;
            bodyGroup.add(rightWheel);

            const leftStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.09, 6), dummyMat);
            leftStrut.position.set(-0.2, -0.045, 0.1);
            bodyGroup.add(leftStrut);

            const rightStrut = leftStrut.clone();
            rightStrut.position.x = 0.2;
            bodyGroup.add(rightStrut);

            const noseWheel = new THREE.Mesh(wheelGeom, dummyMat);
            noseWheel.position.set(0, -0.09, 0.43);
            bodyGroup.add(noseWheel);

            const noseStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.09, 6), dummyMat);
            noseStrut.position.set(0, -0.045, 0.43);
            bodyGroup.add(noseStrut);

            // Propellers (transparent discs) - separate from body
            const leftProp = new THREE.Mesh(new THREE.CircleGeometry(0.14, 16), dummyMat);
            leftProp.position.set(-0.55, -0.05, 0.36);
            propGroup.add(leftProp);

            const rightProp = leftProp.clone();
            rightProp.position.x = 0.55;
            propGroup.add(rightProp);

            return {
                body: mergeGroupToGeometry(bodyGroup),
                props: mergeGroupToGeometry(propGroup)
            };
        }

        // Helicopter Geometry - Detailed with integrated cockpit
        function createHelicopterGeometry() {
            const bodyGroup = new THREE.Group();
            const rotorGroup = new THREE.Group();
            const dummyMat = new THREE.MeshBasicMaterial();

            // Cockpit / front section (integrated with fuselage)
            const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2), dummyMat);
            cockpit.scale.set(1, 1.5, 1);
            cockpit.rotation.x = Math.PI / 2;
            cockpit.position.set(0, 0.05, 0.15);
            bodyGroup.add(cockpit);

            // Main body (rounded cylinder)
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.11, 0.35, 12), dummyMat);
            body.rotation.x = Math.PI / 2;
            body.position.z = -0.05;
            bodyGroup.add(body);

            // Engine cowling on top
            const engine = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.08, 0.2), dummyMat);
            engine.position.set(0, 0.16, 0);
            bodyGroup.add(engine);

            // Main rotor mast
            const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.08, 8), dummyMat);
            mast.position.y = 0.24;
            bodyGroup.add(mast);

            // Rotor hub
            const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.02, 8), dummyMat);
            hub.rotation.x = Math.PI / 2;
            hub.position.y = 0.28;
            bodyGroup.add(hub);

            // Tail boom (tapered cylinder)
            const tailBoom = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.04, 0.6, 8), dummyMat);
            tailBoom.rotation.x = Math.PI / 2;
            tailBoom.position.set(0, 0.03, -0.5);
            bodyGroup.add(tailBoom);

            // Tail fin (swept back)
            const tailFinGeom = new THREE.BufferGeometry();
            const tailFinVerts = new Float32Array([
                -0.005, 0.03, -0.72,  0.005, 0.03, -0.72,
                -0.005, 0.15, -0.77,  0.005, 0.15, -0.77,
                -0.005, 0.03, -0.78,  0.005, 0.03, -0.78,
                -0.005, 0.15, -0.83,  0.005, 0.15, -0.83
            ]);
            const tailFinIndices = [0,2,1, 1,2,3, 4,5,6, 5,7,6, 0,1,4, 1,5,4, 2,6,3, 3,6,7, 0,4,2, 2,4,6, 1,3,5, 3,7,5];
            tailFinGeom.setAttribute('position', new THREE.BufferAttribute(tailFinVerts, 3));
            tailFinGeom.setIndex(tailFinIndices);
            tailFinGeom.computeVertexNormals();
            const tailFin = new THREE.Mesh(tailFinGeom, dummyMat);
            bodyGroup.add(tailFin);

            // Skids with struts
            const leftSkid = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.018, 0.4, 8), dummyMat);
            leftSkid.rotation.x = Math.PI / 2;
            leftSkid.position.set(-0.18, -0.14, 0.05);
            bodyGroup.add(leftSkid);

            const rightSkid = leftSkid.clone();
            rightSkid.position.x = 0.18;
            bodyGroup.add(rightSkid);

            // Skid struts
            const strutGeom = new THREE.CylinderGeometry(0.01, 0.01, 0.16, 6);
            const leftStrutFront = new THREE.Mesh(strutGeom, dummyMat);
            leftStrutFront.rotation.z = -Math.PI / 8;
            leftStrutFront.position.set(-0.18, -0.06, 0.15);
            bodyGroup.add(leftStrutFront);

            const leftStrutRear = leftStrutFront.clone();
            leftStrutRear.position.z = -0.05;
            bodyGroup.add(leftStrutRear);

            const rightStrutFront = leftStrutFront.clone();
            rightStrutFront.rotation.z = Math.PI / 8;
            rightStrutFront.position.x = 0.18;
            bodyGroup.add(rightStrutFront);

            const rightStrutRear = leftStrutRear.clone();
            rightStrutRear.rotation.z = Math.PI / 8;
            rightStrutRear.position.x = 0.18;
            bodyGroup.add(rightStrutRear);

            // Main rotor (transparent disc) - separate from body
            const mainRotor = new THREE.Mesh(new THREE.CircleGeometry(0.75, 32), dummyMat);
            mainRotor.rotation.x = -Math.PI / 2;
            mainRotor.position.y = 0.29;
            rotorGroup.add(mainRotor);

            // Tail rotor (transparent disc) - separate from body
            const tailRotor = new THREE.Mesh(new THREE.CircleGeometry(0.12, 16), dummyMat);
            tailRotor.position.set(0.06, 0.03, -0.8);
            rotorGroup.add(tailRotor);

            return {
                body: mergeGroupToGeometry(bodyGroup),
                props: mergeGroupToGeometry(rotorGroup)
            };
        }

        // Balloon Geometry - Sphere
        function createBalloonGeometry() {
            return new THREE.SphereGeometry(0.4, 16, 16);
        }

        // Heavy Jet Geometry - Larger commercial
        function createHeavyJetGeometry() {
            const geom = createCommercialJetGeometry();
            geom.scale(1.3, 1.3, 1.3);
            return geom;
        }

        // Glider Geometry - Same as commercial
        function createGliderGeometry() {
            return createCommercialJetGeometry();
        }

        // ========== LOD (Level of Detail) GEOMETRY FUNCTIONS ==========

        // LOD Level 1: Medium detail (6-8 segments, simplified components)
        function createSimplifiedGeometry_LOD1(baseType) {
            const group = new THREE.Group();
            const dummyMat = new THREE.MeshBasicMaterial();

            // Simplified fuselage with 6 segments instead of 12
            const fuselage = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.0, 6), dummyMat);
            fuselage.rotation.x = Math.PI / 2;
            group.add(fuselage);

            // Simple nose
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6, 0, Math.PI * 2, 0, Math.PI / 2), dummyMat);
            nose.rotation.x = Math.PI / 2;
            nose.position.z = 0.5;
            group.add(nose);

            // Basic wings (simple box instead of detailed geometry)
            const leftWing = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.02, 0.15), dummyMat);
            leftWing.position.set(-0.45, 0, -0.05);
            group.add(leftWing);

            const rightWing = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.02, 0.15), dummyMat);
            rightWing.position.set(0.45, 0, -0.05);
            group.add(rightWing);

            // Simplified tail
            const vtail = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.25, 0.12), dummyMat);
            vtail.position.set(0, 0.12, -0.65);
            group.add(vtail);

            return mergeGroupToGeometry(group);
        }

        // LOD Level 2: Low detail (4 segments, basic shapes only)
        function createSimplifiedGeometry_LOD2(baseType) {
            const group = new THREE.Group();
            const dummyMat = new THREE.MeshBasicMaterial();

            // Very simple fuselage with only 4 segments
            const fuselage = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.05, 1.2, 4), dummyMat);
            fuselage.rotation.x = Math.PI / 2;
            group.add(fuselage);

            // Simple flat wings
            const wings = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.02, 0.12), dummyMat);
            wings.position.set(0, 0, -0.05);
            group.add(wings);

            // Minimal tail
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.2, 0.08), dummyMat);
            tail.position.set(0, 0.1, -0.6);
            group.add(tail);

            return mergeGroupToGeometry(group);
        }

        // LOD Level 3: Billboard/Impostor (simple pyramid/sprite)
        function createSimplifiedGeometry_LOD3(baseType) {
            // Very simple 4-face pyramid representing an aircraft
            const geometry = new THREE.ConeGeometry(0.08, 0.4, 4);
            geometry.rotateX(-Math.PI / 2);
            return geometry;
        }

        // LOD Level 4: Point sprite (1500-3000 units)
        function createSimplifiedGeometry_LOD4(baseType) {
            // Single triangle for extreme distances
            const geometry = new THREE.ConeGeometry(0.05, 0.2, 3);
            geometry.rotateX(-Math.PI / 2);
            return geometry;
        }

        // LOD Level 5: Minimal dot (3000-8000 units)
        function createSimplifiedGeometry_LOD5(baseType) {
            // Tiny tetrahedron (4 faces)
            const geometry = new THREE.TetrahedronGeometry(0.08, 0);
            return geometry;
        }

        // LOD Level 6: Ultra minimal (8000+ units)
        function createSimplifiedGeometry_LOD6(baseType) {
            // Single point/smallest possible geometry
            const geometry = new THREE.TetrahedronGeometry(0.04, 0);
            return geometry;
        }

        // Create LOD object for an aircraft type
        function createAircraftLOD(fullDetailGeometry, aircraftType) {
            const lod = new THREE.LOD();

            // LOD Level 0: Full detail (0-100 units)
            const mesh0 = new THREE.Mesh(fullDetailGeometry, new THREE.MeshBasicMaterial());
            lod.addLevel(mesh0, 0);

            // LOD Level 1: Medium detail (100-300 units)
            const geom1 = createSimplifiedGeometry_LOD1(aircraftType);
            const mesh1 = new THREE.Mesh(geom1, new THREE.MeshBasicMaterial());
            lod.addLevel(mesh1, 100);

            // LOD Level 2: Low detail (300-700 units)
            const geom2 = createSimplifiedGeometry_LOD2(aircraftType);
            const mesh2 = new THREE.Mesh(geom2, new THREE.MeshBasicMaterial());
            lod.addLevel(mesh2, 300);

            // LOD Level 3: Impostor (700-1500 units)
            const geom3 = createSimplifiedGeometry_LOD3(aircraftType);
            const mesh3 = new THREE.Mesh(geom3, new THREE.MeshBasicMaterial());
            lod.addLevel(mesh3, 700);

            // LOD Level 4: Point sprite (1500-3000 units)
            const geom4 = createSimplifiedGeometry_LOD4(aircraftType);
            const mesh4 = new THREE.Mesh(geom4, new THREE.MeshBasicMaterial());
            lod.addLevel(mesh4, 1500);

            // LOD Level 5: Minimal dot (3000-8000 units)
            const geom5 = createSimplifiedGeometry_LOD5(aircraftType);
            const mesh5 = new THREE.Mesh(geom5, new THREE.MeshBasicMaterial());
            lod.addLevel(mesh5, 3000);

            // LOD Level 6: Ultra minimal (8000+ units)
            const geom6 = createSimplifiedGeometry_LOD6(aircraftType);
            const mesh6 = new THREE.Mesh(geom6, new THREE.MeshBasicMaterial());
            lod.addLevel(mesh6, 8000);

            return lod;
        }

        // ========== END LOD GEOMETRY FUNCTIONS ==========

        // Classify aircraft type based on aircraft data
        function getAircraftGeometry(ac) {
            // Get aircraft type code
            const type = (ac.t || '').toUpperCase();
            const category = (ac.category || '').toUpperCase();

            // Debug logging to see actual aircraft types
            if (Math.random() < 0.01) { // Log ~1% of aircraft to avoid spam
                console.log('Aircraft classification:', { type, category, flight: ac.flight });
            }

            // Helicopters (category A7 or type starts with H, EC, AS, etc.)
            if (category === 'A7' ||
                type.match(/^(H\d|EC\d|AS\d|AW\d|S76|UH\d|CH\d|MH\d|AH\d|BH\d)/)) {
                return aircraftGeometries.helicopter;
            }

            // Balloons and lighter-than-air (category B2)
            if (category === 'B2' || type.match(/^(BALL|BLIM)/)) {
                return aircraftGeometries.balloon;
            }

            // Gliders (category B1)
            if (category === 'B1' || type.match(/^(GLID|ASK|ASW|DG\d|LS\d|JANT)/)) {
                return aircraftGeometries.glider;
            }

            // Heavy aircraft (category A5 or specific types)
            // Includes 747, 777, 787, A350, A380, 757, 767 wide-bodies
            if (category === 'A5' ||
                type.match(/^(B74|B75|B76|B77|B78|A35|A38|A340|AN124|AN225|C5|IL96|MD11)/)) {
                return aircraftGeometries.heavy;
            }

            // Commercial jets - MUST come before multi-engine props to prevent E-jet misclassification
            // Includes: Airbus A220/A320/A330 families, Boeing 737/757/767, Embraer E-Jets, Regional Jets
            if (type.match(/^(A[23][0-9]{2}[A-Z]?|B7[0-3][0-9A-Z]|B[38]M|MD\d{1,2}|DC\d{1,2}|CRJ\w*|E(170|175|190|195|75L|75S|E75)|BCS[135])/)) {
                return aircraftGeometries.commercial;
            }

            // Private/Business jets (light jets and bizjets)
            // Includes: Citations, Challengers, Falcons, Gulfstreams, Globals, Learjets, Pilatus, etc.
            // Also includes Embraer business jets (E135, E145, Legacy, Phenom, Praetor)
            if (type.match(/^(C[0-9]{2,3}[A-Z]?|CL\d|F[0-9]{2,3}|G\d{2,3}|GL(EX|\d)|LJ\d|PC\d|BE\d{2}|H25|HA\d|SJ\d|ECLIPSE|TBM|E(135|145|135|EMB|PHE|PRA))/)) {
                return aircraftGeometries.private;
            }

            // Single engine prop planes
            if (type.match(/^(C1[0-9]{2}|PA\d{2}|SR\d{2}|DA\d{2}|P28|M20|RV\d|BE\d{1}|RANS|VAN)/)) {
                return aircraftGeometries.singleEngine;
            }

            // Multi-engine props (turboprops and piston twins)
            // Tightened E-pattern to avoid catching E-jets (now only matches turboprops like E110 Bandeirante)
            if (type.match(/^(BE[2-9][0-9]|DHC\d|AT\d{2}|SF\d|P\d{2}[^8]|SW\d|E(110|120|121)|AEST|BN\d|DH\d|CVLT)/)) {
                return aircraftGeometries.multiEngine;
            }

            // Default to commercial jet for unknown types
            return aircraftGeometries.commercial;
        }
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);
            scene.fog = new THREE.Fog(0x000510, 4000, 20000); // Max fog distance by default

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 50000);
            camera.position.set(0, 50, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Orbit Controls
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.minDistance = 10;
            orbitControls.maxDistance = 40000; // Increased for continental-scale viewing
            orbitControls.autoRotate = false;
            orbitControls.autoRotateSpeed = 0.5;
            controls = orbitControls;

            // Listen for orbit control interactions
            orbitControls.addEventListener('start', () => {
                if (autoRotateEnabled) {
                    resetIdleTimer();
                }
            });

            // Fly Controls (PointerLock)
            flyControls = new PointerLockControls(camera, renderer.domElement);

            // Setup pointer lock event listeners
            flyControls.addEventListener('lock', () => {
                document.getElementById('fly-instructions').style.display = 'none';
            });

            flyControls.addEventListener('unlock', () => {
                if (isFlyMode) {
                    document.getElementById('fly-instructions').style.display = 'block';
                }
            });

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Ground grid (always at y=0, representing ground level)
            gridHelper = new THREE.GridHelper(200, 40, 0x444444, 0x222222);
            gridHelper.visible = false; // Hidden by default
            scene.add(gridHelper);

            // Axis helper (optional, hidden by default)
            axesHelper = new THREE.AxesHelper(50);
            axesHelper.visible = false;
            scene.add(axesHelper);

            // Groups
            trailGroup = new THREE.Group();
            scene.add(trailGroup);

            aircraftGroup = new THREE.Group();
            scene.add(aircraftGroup);

            // Create aircraft model geometries
            createAircraftGeometries();

            // Create circular texture for aircraft glow halos
            glowCircleTexture = createCircleTexture();

            // Airspace group
            airspaceGroup = new THREE.Group();
            scene.add(airspaceGroup);

            // Tile streaming group
            tilesGroup = new THREE.Group();
            tilesGroup.position.y = -1; // Position tiles slightly below grid
            tilesGroup.visible = !terrainEnabled; // Hide if terrain is enabled
            scene.add(tilesGroup);

            // Terrain group (3D elevation mesh)
            terrainGroup = new THREE.Group();
            terrainGroup.position.set(0, 0, 0); // Terrain aligned with grid at y=0
            scene.add(terrainGroup);
            console.log('✅ Terrain group created and added to scene');

            // Boundaries group (vector country/state borders)
            boundariesGroup = new THREE.Group();
            boundariesGroup.position.set(0, 0.1, 0); // Slightly above ground to prevent z-fighting
            scene.add(boundariesGroup);
            console.log('✅ Boundaries group created and added to scene');

            // Don't initialize tiles here - wait for location to be set in init()
            // Tiles will load after loadRandomUSAirport() or getUserLocation() sets the location

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update Line2 material resolutions
            const newResolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
            aircraftData.forEach((data) => {
                if (data.trail && data.trail.isLine2 && data.trail.material) {
                    data.trail.material.resolution = newResolution;
                }
            });
        }

        // Map tile utilities
        function latLonToTile(lat, lon, zoom) {
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const x = Math.floor((lon + 180) / 360 * n);
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y, z: zoom };
        }

        function tileToLatLon(x, y, zoom) {
            const n = Math.pow(2, zoom);
            const lon = x / n * 360 - 180;
            const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
            const lat = latRad * 180 / Math.PI;
            return { lat, lon };
        }

        // TILE STREAMING UTILITIES
        function getTileKey(x, y, zoom) {
            return `${zoom}_${x}_${y}`;
        }

        function calculateTileCenter(x, y, zoom) {
            // Get center lat/lon of tile for distance calculations
            const topLeft = tileToLatLon(x, y, zoom);
            const bottomRight = tileToLatLon(x + 1, y + 1, zoom);
            return {
                lat: (topLeft.lat + bottomRight.lat) / 2,
                lon: (topLeft.lon + bottomRight.lon) / 2
            };
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula for distance in km
            const latDiff = Math.abs(lat2 - lat1);
            const lonDiff = Math.abs(lon2 - lon1);
            return Math.sqrt(
                Math.pow(latDiff * 111.32, 2) +
                Math.pow(lonDiff * 111.32 * Math.cos(lat1 * Math.PI / 180), 2)
            );
        }

        // FRUSTUM CULLING UTILITIES
        function getCameraViewCenter() {
            // Project camera position onto ground plane to get view center
            // Camera is at (x, y, z) in 3D space
            // Ground plane is at y = 0
            // Ray from camera through look-at point hits ground at view center

            const cameraPos = camera.position;
            const target = orbitControls.target;

            // For orbit controls, target IS the ground center point
            // Convert 3D position back to lat/lon
            const centerX = target.x;
            const centerZ = target.z;

            const lon = config.centerLon + (centerX / (111.32 * Math.cos(config.centerLat * Math.PI / 180)));
            const lat = config.centerLat - (centerZ / 111.32);

            return { lat, lon };
        }

        function getVisibleRadius() {
            // Calculate approximate radius of ground visible from camera
            // Based on camera height and FOV
            const cameraHeight = camera.position.y;
            const fovRadians = camera.fov * Math.PI / 180;

            // Distance from camera to orbit target
            const distToTarget = camera.position.distanceTo(orbitControls.target);

            // Visible radius on ground = distance * tan(fov/2) * safety factor
            // Increased to 3.0x to ensure full coverage with generous margins
            const visibleRadius = distToTarget * Math.tan(fovRadians / 2) * 3.0;

            return visibleRadius; // in km
        }

        function isTileInView(tileX, tileY, zoom, viewCenterLat, viewCenterLon, viewRadius) {
            // Calculate tile center
            const tileCenter = calculateTileCenter(tileX, tileY, zoom);

            // Calculate distance from view center to tile center
            const dist = calculateDistance(viewCenterLat, viewCenterLon, tileCenter.lat, tileCenter.lon);

            // Tile is visible if within view radius (plus safety margin)
            const kmPerTile = 39.1; // zoom 10
            const margin = kmPerTile * 4; // Generous margin for edge coverage
            return dist <= (viewRadius + margin);
        }

        // Helper function to convert HSL to RGB color
        function getTerrainColor() {
            const hue = config.terrainColorHue;
            const brightness = config.terrainBrightness / 100.0;

            if (hue === 0) {
                // Gray (no hue)
                return new THREE.Color(brightness, brightness, brightness);
            } else {
                // Convert HSL to RGB
                const h = hue / 360.0;
                const s = 0.6; // Fixed saturation
                const l = brightness * 0.5; // Lightness based on brightness

                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return new THREE.Color(r, g, b);
            }
        }

        // Create a material with circular radius masking (for focused tiles mode)
        function createRadiusMaskedMaterial(texture, isWireframe = false, minElev = 0, maxElev = 1) {
            const terrainColor = getTerrainColor();

            if (!focusedTilesMode) {
                // Not in focused mode, return standard material
                if (isWireframe) {
                    return new THREE.MeshBasicMaterial({
                        color: terrainColor,
                        wireframe: true
                    });
                } else {
                    // Use shader material for brightness even without focused mode
                    if (mapBrightness !== 1.0) {
                        const material = new THREE.ShaderMaterial({
                            uniforms: {
                                map: { value: texture },
                                brightness: { value: mapBrightness }
                            },
                            vertexShader: `
                                varying vec2 vUv;
                                void main() {
                                    vUv = uv;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `,
                            fragmentShader: `
                                uniform sampler2D map;
                                uniform float brightness;
                                varying vec2 vUv;

                                void main() {
                                    vec4 baseColor = texture2D(map, vUv);

                                    // Apply brightness
                                    baseColor.rgb *= brightness;

                                    gl_FragColor = baseColor;
                                }
                            `,
                            side: THREE.DoubleSide,
                            transparent: false
                        });
                        return material;
                    } else {
                        // Standard material if no effects needed
                        return new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: false,
                            side: THREE.DoubleSide
                        });
                    }
                }
            }

            // In focused mode, use custom shader with radius masking and gradient
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: texture },
                    useTexture: { value: !isWireframe },
                    wireframeColor: { value: terrainColor },
                    centerLat: { value: config.centerLat },
                    centerLon: { value: config.centerLon },
                    refLat: { value: config.centerLat },
                    refLon: { value: config.centerLon },
                    searchRadius: { value: config.radius },
                    altitudeScale: { value: config.altitudeScale },
                    minElevation: { value: minElev },
                    maxElevation: { value: maxElev },
                    gradientEnabled: { value: config.elevationGradient },
                    gradientIntensity: { value: config.gradientIntensity },
                    brightness: { value: mapBrightness }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    varying vec3 vPosition;

                    void main() {
                        vUv = uv;
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPos.xyz;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D map;
                    uniform bool useTexture;
                    uniform vec3 wireframeColor;
                    uniform float centerLat;
                    uniform float centerLon;
                    uniform float refLat;
                    uniform float refLon;
                    uniform float searchRadius;
                    uniform float altitudeScale;
                    uniform float minElevation;
                    uniform float maxElevation;
                    uniform bool gradientEnabled;
                    uniform float gradientIntensity;
                    uniform float brightness;

                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    varying vec3 vPosition;

                    #define PI 3.14159265359

                    void main() {
                        // Convert centerLat/centerLon to world coordinates relative to reference point
                        // x = (lon - refLon) * 111.32 * cos(refLat * PI / 180)
                        // z = -(lat - refLat) * 111.32
                        float centerX = (centerLon - refLon) * 111.32 * cos(refLat * PI / 180.0);
                        float centerZ = -(centerLat - refLat) * 111.32;
                        vec2 centerPos = vec2(centerX, centerZ);

                        // Calculate distance from aircraft center, not from origin
                        vec2 worldPos = vWorldPosition.xz; // x and z are horizontal plane
                        float dist = length(worldPos - centerPos);

                        // Discard fragments outside search radius
                        if (dist > searchRadius) {
                            discard;
                        }

                        // Base color
                        vec4 baseColor;
                        if (useTexture) {
                            baseColor = texture2D(map, vUv);
                        } else {
                            baseColor = vec4(wireframeColor, 1.0);
                        }

                        // Apply elevation gradient if enabled
                        if (gradientEnabled && !useTexture) {
                            // Get elevation from Z component (before rotation this is vertical)
                            float elevation = vPosition.z;

                            // Calculate relative elevation (0 to 1)
                            float elevRange = maxElevation - minElevation;
                            float relativeElev = elevRange > 0.0 ? (elevation - minElevation) / elevRange : 0.5;
                            relativeElev = clamp(relativeElev, 0.0, 1.0);

                            // Apply gradient with intensity control
                            // Brightness variation: darker at low elevation, brighter at high
                            float brightnessRange = 0.4 * gradientIntensity;
                            float elevBrightness = mix(1.0 - brightnessRange, 1.0 + brightnessRange, relativeElev);

                            baseColor.rgb *= elevBrightness;
                        }

                        // Apply map brightness (for textures)
                        if (useTexture) {
                            baseColor.rgb *= brightness;
                        }

                        gl_FragColor = baseColor;
                    }
                `,
                side: THREE.DoubleSide,
                wireframe: isWireframe,
                transparent: false
            });

            return material;
        }

        // Load a single tile and create its mesh
        function loadTile(x, y, zoom, layerType, refLat, refLon) {
            const tileKey = getTileKey(x, y, zoom);

            // Skip if already loaded or loading
            if (loadedTiles.has(tileKey)) {
                return;
            }

            // Calculate tile bounds FIRST
            const topLeft = tileToLatLon(x, y, zoom);
            const bottomRight = tileToLatLon(x + 1, y + 1, zoom);
            const center = calculateTileCenter(x, y, zoom);

            // Add placeholder immediately to prevent duplicate loads
            loadedTiles.set(tileKey, {
                loading: true,
                x,
                y,
                zoom,
                lat: center.lat,
                lon: center.lon
            });

            // Determine tile URL based on layer type
            // Using dark tiles with no political boundaries
            let tileUrlTemplate;
            if (layerType === 'dark') {
                tileUrlTemplate = 'https://a.basemaps.cartocdn.com/rastertiles/dark_nolabels/{z}/{x}/{y}@2x.png';
            } else if (layerType === 'dark-nolabels') {
                tileUrlTemplate = 'https://a.basemaps.cartocdn.com/rastertiles/dark_nolabels/{z}/{x}/{y}@2x.png';
            }

            const tileUrl = tileUrlTemplate
                .replace('{z}', zoom)
                .replace('{x}', x)
                .replace('{y}', y);

            // Convert to 3D coordinates using reference point
            const topLeftPos = latLonToCartesianWithRef(topLeft.lat, topLeft.lon, config.floorHeight, refLat, refLon);
            const bottomRightPos = latLonToCartesianWithRef(bottomRight.lat, bottomRight.lon, config.floorHeight, refLat, refLon);

            // Calculate plane dimensions
            const planeWidth = Math.abs(bottomRightPos.x - topLeftPos.x);
            const planeHeight = Math.abs(bottomRightPos.z - topLeftPos.z);
            const centerX = (topLeftPos.x + bottomRightPos.x) / 2;
            const centerZ = (topLeftPos.z + bottomRightPos.z) / 2;

            // Load texture
            const textureLoader = new THREE.TextureLoader();
            textureLoader.setCrossOrigin('anonymous');

            textureLoader.load(
                tileUrl,
                (texture) => {
                    // Check if tile was unloaded while loading
                    const tileData = loadedTiles.get(tileKey);
                    if (!tileData) {
                        texture.dispose();
                        return;
                    }

                    // Configure texture
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                    // Create geometry and material
                    const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                    const material = createRadiusMaskedMaterial(texture, false);

                    // Create mesh
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.x = -Math.PI / 2; // Horizontal
                    mesh.position.set(centerX, 0, centerZ); // Flat on ground plane

                    // Add to group
                    tilesGroup.add(mesh);

                    // Update tile data (replace placeholder with full data)
                    loadedTiles.set(tileKey, {
                        mesh,
                        material,
                        texture,
                        geometry,
                        x,
                        y,
                        zoom,
                        lat: center.lat,
                        lon: center.lon,
                        loading: false
                    });

                    // Tile loaded successfully (logging done in batch by updateVisibleTiles)
                },
                undefined,
                (error) => {
                    console.warn(`❌ Failed to load tile ${tileKey}:`, error);
                    // Remove placeholder on error
                    loadedTiles.delete(tileKey);
                }
            );
        }

        // Unload a tile and dispose of its resources
        function unloadTile(tileKey) {
            const tile = loadedTiles.get(tileKey);
            if (!tile) return;

            // Remove from scene (only if fully loaded)
            if (tile.mesh) {
                tilesGroup.remove(tile.mesh);
            }

            // Dispose resources (only if fully loaded)
            if (tile.geometry) tile.geometry.dispose();
            if (tile.material) tile.material.dispose();
            if (tile.texture) tile.texture.dispose();

            // Remove from tracking
            loadedTiles.delete(tileKey);
        }

        // Main tile streaming function - loads/unloads tiles based on position with LOD
        function updateVisibleTiles(centerLat, centerLon, radiusKm, layerType) {
            if (layerType === 'none') {
                // Clear all tiles
                for (const tileKey of loadedTiles.keys()) {
                    unloadTile(tileKey);
                }
                return;
            }

            // CAMERA-BASED TILE LOADING (frustum culling)
            // Only load tiles actually visible from camera - keeps memory low!

            // Get camera view center and visible radius
            // FLIGHT FOLLOWING: Use aircraft position directly instead of camera calculation
            const isFollowingAircraft = followedAircraftHex !== null && centerLat !== config.centerLat;
            let viewCenter, viewRadius;

            if (isFollowingAircraft) {
                // Use aircraft position directly (more reliable when far from origin)
                viewCenter = { lat: centerLat, lon: centerLon };
                viewRadius = radiusKm;
            } else {
                // Use camera-based calculation
                viewCenter = getCameraViewCenter();
                viewRadius = getVisibleRadius();
            }

            // Keep tilesGroup at fixed position - all tiles use config.centerLat/centerLon as reference
            // This ensures consistent positioning regardless of panning or flight following
            tilesGroup.position.set(0, -1, 0);

            // LOCKED ZOOM LEVEL 10 - Always highest detail
            const zoomLevel = 10;
            const kmPerTile = 39.1;

            const tilesToLoad = new Set();

            // Calculate center tile based on what camera is looking at
            const viewCenterTile = latLonToTile(viewCenter.lat, viewCenter.lon, zoomLevel);

            // Calculate grid radius to cover visible area
            const radiusMultiplier = 3.5;
            const extraTiles = 5;
            const tilesNeeded = Math.ceil((viewRadius * radiusMultiplier) / kmPerTile);
            const gridRadius = Math.ceil(tilesNeeded / 2) + extraTiles;

            // Debug logging (only when tiles are loaded)
            // console.log(`📷 Camera view: center (${viewCenter.lat.toFixed(2)}, ${viewCenter.lon.toFixed(2)}), radius ${viewRadius.toFixed(0)}km, ${tilesNeeded}x${tilesNeeded} tiles`);

            // Load tiles within camera view
            for (let dy = -gridRadius; dy <= gridRadius; dy++) {
                for (let dx = -gridRadius; dx <= gridRadius; dx++) {
                    const tileX = viewCenterTile.x + dx;
                    const tileY = viewCenterTile.y + dy;

                    // Check if tile is actually visible from camera
                    if (isTileInView(tileX, tileY, zoomLevel, viewCenter.lat, viewCenter.lon, viewRadius)) {
                        // FOCUSED TILES MODE: Additional check that tile is within search radius from center
                        if (focusedTilesMode) {
                            const tileCenter = calculateTileCenter(tileX, tileY, zoomLevel);
                            const distFromCenter = calculateDistance(centerLat, centerLon, tileCenter.lat, tileCenter.lon);
                            // Load tiles beyond search radius (90% buffer) to ensure full coverage
                            const TILE_BUFFER_PERCENT = 0.90;
                            if (distFromCenter > config.radius * (1 + TILE_BUFFER_PERCENT)) {
                                continue; // Skip this tile
                            }
                        }

                        const tileKey = getTileKey(tileX, tileY, zoomLevel);
                        tilesToLoad.add(tileKey);
                    }
                }
            }

            // Hide/show and unload tiles based on distance (visibility culling for performance)
            const tilesToUnload = [];
            const tilesToHide = [];
            const tilesToShow = [];
            const UNLOAD_MARGIN_KM = isMobileDevice ? 500 : 200; // Distance to hide tiles
            const DISPOSE_MARGIN_KM = isMobileDevice ? 1000 : 500; // Distance to actually dispose tiles (2x hide distance)

            for (const [tileKey, tile] of loadedTiles.entries()) {
                // Don't process tiles still loading
                if (tile.loading) continue;

                let shouldHide = false;
                let shouldDispose = false;

                // Calculate distance from view center to tile
                const dist = calculateDistance(viewCenter.lat, viewCenter.lon, tile.lat, tile.lon);

                // Check if tile should be hidden (outside view) or disposed (very far)
                if (dist > viewRadius + DISPOSE_MARGIN_KM) {
                    shouldDispose = true; // Very far - actually dispose
                } else if (dist > viewRadius + UNLOAD_MARGIN_KM) {
                    shouldHide = true; // Far but not too far - just hide
                }

                // FOCUSED MODE: Also check distance from center
                if (focusedTilesMode) {
                    const TILE_BUFFER_PERCENT = 0.75;
                    const distFromCenter = calculateDistance(centerLat, centerLon, tile.lat, tile.lon);
                    if (distFromCenter > config.radius * (1 + TILE_BUFFER_PERCENT) * 2) {
                        shouldDispose = true; // Very far from center - dispose
                    } else if (distFromCenter > config.radius * (1 + TILE_BUFFER_PERCENT)) {
                        shouldHide = true; // Outside focused radius - hide
                    }
                }

                if (shouldDispose) {
                    tilesToUnload.push(tileKey);
                } else if (shouldHide && tile.mesh) {
                    tilesToHide.push(tile.mesh);
                } else if (!shouldHide && tile.mesh && !tile.mesh.visible) {
                    tilesToShow.push(tile.mesh);
                }
            }

            // Hide distant tiles (keep in memory, just invisible)
            for (const mesh of tilesToHide) {
                mesh.visible = false;
            }

            // Show tiles that came back into range
            for (const mesh of tilesToShow) {
                mesh.visible = true;
            }

            // Dispose only very distant tiles
            for (const tileKey of tilesToUnload) {
                unloadTile(tileKey);
            }

            if (tilesToHide.length > 0 || tilesToShow.length > 0 || tilesToUnload.length > 0) {
                console.log(`👁️ Tile visibility: ${tilesToShow.length} shown, ${tilesToHide.length} hidden, ${tilesToUnload.length} disposed`);
            }

            // Load new tiles (up to max limit)
            let tilesLoaded = 0;
            for (const tileKey of tilesToLoad) {
                if (loadedTiles.size >= MAX_LOADED_TILES) {
                    console.warn(`⚠️ Hit tile limit (${MAX_LOADED_TILES})`);
                    break; // Hit limit
                }

                if (!loadedTiles.has(tileKey)) {
                    const [z, x, y] = tileKey.split('_').map(Number);
                    // ALWAYS use config center as reference - consistent coordinate system!
                    loadTile(x, y, z, layerType, config.centerLat, config.centerLon);
                    tilesLoaded++;
                }
            }

            if (tilesLoaded > 0) {
                console.log(`🗺️ Camera-based tiles: Loaded ${tilesLoaded} new, unloaded ${tilesToUnload.length}, ${loadedTiles.size} total in memory`);
            }
        }

        // ========== TERRAIN SYSTEM ==========

        // Decode elevation from RGB pixel data (Mapzen Terrarium format only)
        function decodeElevation(r, g, b) {
            // Mapzen Terrarium format: elevation = (R * 256 + G + B / 256) - 32768
            return (r * 256 + g + b / 256) - 32768;
        }

        // Load a terrain tile with elevation data (Mapzen Terrarium only)
        function loadTerrainTile(x, y, zoom, refLat, refLon) {
            const tileKey = getTileKey(x, y, zoom);

            // Skip if already loaded or loading
            if (loadedTerrainTiles.has(tileKey)) {
                return;
            }

            // Add placeholder
            loadedTerrainTiles.set(tileKey, { loading: true });

            // Calculate tile bounds
            const topLeft = tileToLatLon(x, y, zoom);
            const bottomRight = tileToLatLon(x + 1, y + 1, zoom);
            const center = calculateTileCenter(x, y, zoom);

            // Mapzen Terrarium tile URL (free, no API key)
            const terrainUrl = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${zoom}/${x}/${y}.png`;

            // MATCH MAP TILE POSITIONING EXACTLY (handles Web Mercator projection correctly)
            // Convert tile corners to 3D coordinates using same method as map tiles
            const topLeftPos = latLonToCartesianWithRef(topLeft.lat, topLeft.lon, 0, refLat, refLon);
            const bottomRightPos = latLonToCartesianWithRef(bottomRight.lat, bottomRight.lon, 0, refLat, refLon);

            // Calculate plane dimensions and center (exactly like map tiles)
            const planeWidth = Math.abs(bottomRightPos.x - topLeftPos.x);
            const planeHeight = Math.abs(bottomRightPos.z - topLeftPos.z);
            const centerX = (topLeftPos.x + bottomRightPos.x) / 2;
            const centerZ = (topLeftPos.z + bottomRightPos.z) / 2;

            // LOD: Calculate distance-based segment density for performance
            const tileCenterPos = new THREE.Vector3(centerX, 0, centerZ);
            const distanceToCamera = camera.position.distanceTo(tileCenterPos);

            // Determine segment density based on distance (LOD)
            let dynamicSegmentDensity;
            if (distanceToCamera < 100) {
                dynamicSegmentDensity = 64; // High detail (0-100 units)
            } else if (distanceToCamera < 300) {
                dynamicSegmentDensity = 32; // Medium detail (100-300 units)
            } else if (distanceToCamera < 600) {
                dynamicSegmentDensity = 16; // Low detail (300-600 units)
            } else {
                dynamicSegmentDensity = 8;  // Very low detail (600+ units)
            }

            // Load elevation texture
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                // Check if tile was unloaded while loading
                if (!loadedTerrainTiles.has(tileKey)) return;

                // Draw image to canvas to get pixel data
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Create geometry with subdivisions (LOD-based dynamic density)
                const geometry = new THREE.PlaneGeometry(
                    planeWidth,
                    planeHeight,
                    dynamicSegmentDensity,
                    dynamicSegmentDensity
                );

                // Displace vertices based on elevation data
                const positions = geometry.attributes.position;
                const segmentsX = dynamicSegmentDensity;
                const segmentsY = dynamicSegmentDensity;

                // Track min/max elevation for gradient
                let minElev = Infinity;
                let maxElev = -Infinity;

                for (let iy = 0; iy <= segmentsY; iy++) {
                    for (let ix = 0; ix <= segmentsX; ix++) {
                        const index = iy * (segmentsX + 1) + ix;

                        // SHARED EDGE SAMPLING: Sample at exact pixel positions
                        // This ensures edges of adjacent tiles sample identical elevations
                        // Using floor() ensures consistent sampling across tile boundaries
                        const px = Math.floor((ix / segmentsX) * (canvas.width - 1));
                        const py = Math.floor((iy / segmentsY) * (canvas.height - 1));
                        const pixelIndex = (py * canvas.width + px) * 4;

                        const r = imageData.data[pixelIndex];
                        const g = imageData.data[pixelIndex + 1];
                        const b = imageData.data[pixelIndex + 2];

                        const elevation = decodeElevation(r, g, b);

                        // Apply elevation with exaggeration
                        // Displace in Z, which becomes Y (up) after -90° X rotation
                        // Subtract floor height to align ground level with y=0 (same as aircraft positioning)
                        const floorHeightMeters = config.floorHeight * 0.3048; // Convert feet to meters
                        const elevationScaled = ((elevation - floorHeightMeters) * terrainExaggeration) * config.altitudeScale / 1000;
                        positions.setZ(index, elevationScaled);

                        // Track elevation range
                        minElev = Math.min(minElev, elevationScaled);
                        maxElev = Math.max(maxElev, elevationScaled);

                        // Track global elevation range across all tiles
                        globalMinElev = Math.min(globalMinElev, elevationScaled);
                        globalMaxElev = Math.max(globalMaxElev, elevationScaled);
                    }
                }

                geometry.computeVertexNormals(); // Smooth lighting

                // LOAD TEXTURE BASED ON MODE
                if (terrainTextureMode === 'wireframe') {
                    // WIREFRAME MODE: White lines, no texture
                    const material = createRadiusMaskedMaterial(null, true, minElev, maxElev);

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.x = -Math.PI / 2;
                    mesh.position.set(centerX, 0, centerZ); // At ground level (0,0,0)

                    terrainGroup.add(mesh);

                    loadedTerrainTiles.set(tileKey, {
                        mesh, material, geometry,
                        x, y, zoom,
                        lat: center.lat,
                        lon: center.lon,
                        minElev, maxElev,
                        loading: false
                    });

                    console.log(`🏔️ Terrain tile loaded (wireframe): ${tileKey}`);

                    // Update all materials with global elevation range for consistent gradient
                    updateTerrainGradientRange();

                } else {
                    // MAP MODE: Load texture tile
                    let textureUrl;
                    if (terrainTextureMode === 'map') {
                        // Use current map layer texture
                        if (currentMapLayer === 'dark') {
                            textureUrl = `https://a.basemaps.cartocdn.com/dark_all/${zoom}/${x}/${y}@2x.png`;
                        } else if (currentMapLayer === 'dark-nolabels') {
                            textureUrl = `https://a.basemaps.cartocdn.com/dark_nolabels/${zoom}/${x}/${y}@2x.png`;
                        } else {
                            textureUrl = `https://a.basemaps.cartocdn.com/dark_nolabels/${zoom}/${x}/${y}@2x.png`;
                        }
                    } else if (terrainTextureMode === 'satellite') {
                        // ESRI World Imagery (free satellite tiles)
                        textureUrl = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`;
                    }

                    // Load texture
                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.setCrossOrigin('anonymous');
                    textureLoader.load(
                        textureUrl,
                        (texture) => {
                            const tileData = loadedTerrainTiles.get(tileKey);
                            if (!tileData) {
                                texture.dispose();
                                return;
                            }

                            // Configure texture
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                            // Create material with texture (with radius masking if in focused mode)
                            const material = createRadiusMaskedMaterial(texture, false, minElev, maxElev);

                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.rotation.x = -Math.PI / 2;
                            mesh.position.set(centerX, 0, centerZ); // At ground level (0,0,0)
                            mesh.receiveShadow = true;

                            terrainGroup.add(mesh);

                            // Update with complete data
                            loadedTerrainTiles.set(tileKey, {
                                mesh, material, geometry, texture,
                                x, y, zoom,
                                lat: center.lat,
                                lon: center.lon,
                                minElev, maxElev,
                                loading: false
                            });

                            console.log(`🏔️ Terrain tile loaded (${terrainTextureMode}): ${tileKey}`);

                            // Update all materials with global elevation range for consistent gradient
                            updateTerrainGradientRange();
                        },
                        undefined,
                        (error) => {
                            console.warn(`❌ Failed to load terrain texture ${tileKey}:`, error);
                            loadedTerrainTiles.delete(tileKey);
                        }
                    );
                }
            };

            img.onerror = (error) => {
                console.warn(`❌ Failed to load terrain tile ${tileKey} from ${terrainUrl}`, error);
                loadedTerrainTiles.delete(tileKey);
            };

            console.log(`🌐 Loading terrain tile ${tileKey} from Mapzen Terrarium: ${terrainUrl}`);
            img.src = terrainUrl;
        }

        // Update all terrain materials with global elevation range for consistent gradient
        function updateTerrainGradientRange() {
            if (globalMinElev === Infinity || globalMaxElev === -Infinity) return;

            loadedTerrainTiles.forEach(tile => {
                if (tile.material && tile.material.uniforms) {
                    if (tile.material.uniforms.minElevation) {
                        tile.material.uniforms.minElevation.value = globalMinElev;
                    }
                    if (tile.material.uniforms.maxElevation) {
                        tile.material.uniforms.maxElevation.value = globalMaxElev;
                    }
                }
            });
        }

        // Unload a terrain tile
        function unloadTerrainTile(tileKey) {
            const tile = loadedTerrainTiles.get(tileKey);
            if (!tile) return;

            if (tile.mesh) terrainGroup.remove(tile.mesh);
            if (tile.geometry) tile.geometry.dispose();
            if (tile.material) tile.material.dispose();
            if (tile.texture) tile.texture.dispose(); // Dispose texture if present

            loadedTerrainTiles.delete(tileKey);
        }

        // Update terrain tiles (same logic as map tiles)
        function updateVisibleTerrainTiles(centerLat, centerLon, radiusKm) {
            if (!terrainEnabled) {
                // Clear all terrain tiles
                for (const tileKey of loadedTerrainTiles.keys()) {
                    unloadTerrainTile(tileKey);
                }
                return;
            }

            // Use same camera-based logic as map tiles
            // FLIGHT FOLLOWING: Use aircraft position directly instead of camera calculation
            const isFollowingAircraft = followedAircraftHex !== null && centerLat !== config.centerLat;
            let viewCenter, viewRadius;

            if (isFollowingAircraft) {
                // Use aircraft position directly (more reliable when far from origin)
                viewCenter = { lat: centerLat, lon: centerLon };
                viewRadius = radiusKm;
            } else {
                // Use camera-based calculation
                viewCenter = getCameraViewCenter();
                viewRadius = getVisibleRadius();
            }

            const zoomLevel = 10;
            const kmPerTile = 39.1;

            const tilesToLoad = new Set();
            const viewCenterTile = latLonToTile(viewCenter.lat, viewCenter.lon, zoomLevel);

            const radiusMultiplier = 3.5;
            const extraTiles = 5;
            const tilesNeeded = Math.ceil((viewRadius * radiusMultiplier) / kmPerTile);
            const gridRadius = Math.ceil(tilesNeeded / 2) + extraTiles;

            // Load terrain tiles within camera view
            for (let dy = -gridRadius; dy <= gridRadius; dy++) {
                for (let dx = -gridRadius; dx <= gridRadius; dx++) {
                    const tileX = viewCenterTile.x + dx;
                    const tileY = viewCenterTile.y + dy;

                    if (isTileInView(tileX, tileY, zoomLevel, viewCenter.lat, viewCenter.lon, viewRadius)) {
                        // FOCUSED TILES MODE: Additional check that tile is within search radius from center
                        if (focusedTilesMode) {
                            const tileCenter = calculateTileCenter(tileX, tileY, zoomLevel);
                            const distFromCenter = calculateDistance(centerLat, centerLon, tileCenter.lat, tileCenter.lon);
                            // Load tiles beyond search radius (75% buffer) to ensure full coverage
                            const TILE_BUFFER_PERCENT = 0.75;
                            if (distFromCenter > config.radius * (1 + TILE_BUFFER_PERCENT)) {
                                continue; // Skip this tile
                            }
                        }

                        const tileKey = getTileKey(tileX, tileY, zoomLevel);
                        tilesToLoad.add(tileKey);
                    }
                }
            }

            // Hide/show and unload terrain tiles based on distance (visibility culling for performance)
            const tilesToUnload = [];
            const tilesToHide = [];
            const tilesToShow = [];
            const UNLOAD_MARGIN_KM = isMobileDevice ? 500 : 200; // Distance to hide tiles
            const DISPOSE_MARGIN_KM = isMobileDevice ? 1000 : 500; // Distance to actually dispose tiles

            for (const [tileKey, tile] of loadedTerrainTiles.entries()) {
                if (tile.loading) continue;

                let shouldHide = false;
                let shouldDispose = false;

                const dist = calculateDistance(viewCenter.lat, viewCenter.lon, tile.lat, tile.lon);

                // Check if tile should be hidden or disposed
                if (dist > viewRadius + DISPOSE_MARGIN_KM) {
                    shouldDispose = true;
                } else if (dist > viewRadius + UNLOAD_MARGIN_KM) {
                    shouldHide = true;
                }

                // FOCUSED MODE: Also check distance from center
                if (focusedTilesMode) {
                    const TILE_BUFFER_PERCENT = 0.75;
                    const distFromCenter = calculateDistance(centerLat, centerLon, tile.lat, tile.lon);
                    if (distFromCenter > config.radius * (1 + TILE_BUFFER_PERCENT) * 2) {
                        shouldDispose = true;
                    } else if (distFromCenter > config.radius * (1 + TILE_BUFFER_PERCENT)) {
                        shouldHide = true;
                    }
                }

                if (shouldDispose) {
                    tilesToUnload.push(tileKey);
                } else if (shouldHide && tile.mesh) {
                    tilesToHide.push(tile.mesh);
                } else if (!shouldHide && tile.mesh && !tile.mesh.visible) {
                    tilesToShow.push(tile.mesh);
                }
            }

            // Hide distant terrain tiles
            for (const mesh of tilesToHide) {
                mesh.visible = false;
            }

            // Show terrain tiles that came back into range
            for (const mesh of tilesToShow) {
                mesh.visible = true;
            }

            // Dispose only very distant terrain tiles
            for (const tileKey of tilesToUnload) {
                unloadTerrainTile(tileKey);
            }

            // Load new terrain tiles
            let tilesLoaded = 0;
            for (const tileKey of tilesToLoad) {
                if (loadedTerrainTiles.size >= MAX_LOADED_TILES) break;

                if (!loadedTerrainTiles.has(tileKey)) {
                    const [z, x, y] = tileKey.split('_').map(Number);
                    loadTerrainTile(x, y, z, config.centerLat, config.centerLon);
                    tilesLoaded++;
                }
            }

            if (tilesLoaded > 0 || tilesToUnload.length > 0) {
                console.log(`🏔️ Terrain tiles: Loaded ${tilesLoaded} new, unloaded ${tilesToUnload.length}, ${loadedTerrainTiles.size} total`);
            }

            // Debug: log terrain group state
            if (terrainEnabled && loadedTerrainTiles.size > 0) {
                console.log(`🏔️ Terrain group has ${terrainGroup.children.length} meshes visible in scene`);
            }
        }

        // ========== END TERRAIN SYSTEM ==========

        // ========== VECTOR BOUNDARY SYSTEM ==========

        // Load and render world boundaries from TopoJSON
        async function loadWorldBoundaries(resolution = '110m') {
            if (boundariesLoaded) return; // Already loaded

            console.log(`🌍 Loading world boundaries (${resolution} resolution)...`);

            try {
                // Load TopoJSON from CDN
                const url = `https://cdn.jsdelivr.net/npm/world-atlas@2/countries-${resolution}.json`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load boundaries: ${response.statusText}`);

                const topology = await response.json();

                // Convert TopoJSON to GeoJSON (requires topojson-client library)
                if (typeof topojson === 'undefined') {
                    console.error('❌ TopoJSON library not loaded');
                    return;
                }

                const countries = topojson.feature(topology, topology.objects.countries);
                console.log(`✅ Loaded ${countries.features.length} countries`);

                // Create THREE.js line geometry for each country
                const boundaryMaterial = new THREE.LineBasicMaterial({
                    color: 0x888888,
                    opacity: 0.4,
                    transparent: true,
                    depthTest: false // Always visible over terrain
                });

                countries.features.forEach(feature => {
                    if (!feature.geometry) return;

                    const coords = feature.geometry.coordinates;
                    const geometryType = feature.geometry.type;

                    // Handle both Polygon and MultiPolygon
                    if (geometryType === 'Polygon') {
                        createBoundaryLines(coords, boundaryMaterial);
                    } else if (geometryType === 'MultiPolygon') {
                        coords.forEach(polygon => {
                            createBoundaryLines(polygon, boundaryMaterial);
                        });
                    }
                });

                boundariesLoaded = true;
                console.log(`✅ World boundaries rendered (${boundariesGroup.children.length} line segments)`);

            } catch (error) {
                console.error('❌ Error loading world boundaries:', error);
            }
        }

        // Create THREE.Line from polygon coordinates
        function createBoundaryLines(polygonCoords, material) {
            // polygonCoords is an array of rings (outer + holes)
            // We only render the outer ring (index 0) for simplicity
            const outerRing = polygonCoords[0];
            if (!outerRing || outerRing.length < 2) return;

            const positions = [];

            // Convert lat/lon coordinates to 3D positions
            outerRing.forEach(([lon, lat]) => {
                const pos = latLonToCartesian(lat, lon, 0); // altitude = 0 (ground level)
                positions.push(pos.x, pos.y, pos.z);
            });

            // Create line geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const line = new THREE.Line(geometry, material);
            boundariesGroup.add(line);
        }

        // Clear all boundary lines from the scene
        function clearBoundaries() {
            if (!boundariesGroup) return;

            // Dispose of all boundary line geometries and materials
            while (boundariesGroup.children.length > 0) {
                const child = boundariesGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                boundariesGroup.remove(child);
            }

            // Reset the loaded flag to allow reloading
            boundariesLoaded = false;

            console.log('🗺️ Boundaries cleared');
        }

        // ========== END VECTOR BOUNDARY SYSTEM ==========

        function createMapPlane(layerType) {
            // Increment token to invalidate any pending map loads
            mapLoadingToken++;
            const thisToken = mapLoadingToken;

            // Remove existing map plane with proper cleanup
            if (mapPlane) {
                scene.remove(mapPlane);
                if (mapPlane.geometry) {
                    mapPlane.geometry.dispose();
                }
                if (mapPlane.material) {
                    if (mapPlane.material.map) {
                        mapPlane.material.map.dispose();
                    }
                    mapPlane.material.dispose();
                }
                mapPlane = null;
            }

            if (layerType === 'none') return;

            // Determine tile URL based on layer type - using tiles without political boundaries
            let tileUrlTemplate;
            if (layerType === 'dark') {
                tileUrlTemplate = 'https://a.basemaps.cartocdn.com/rastertiles/dark_nolabels/{z}/{x}/{y}.png';
            } else if (layerType === 'dark-nolabels') {
                tileUrlTemplate = 'https://a.basemaps.cartocdn.com/rastertiles/dark_nolabels/{z}/{x}/{y}.png';
            }

            // LOCKED ZOOM LEVEL - Never changes, ensures consistent scale
            const zoom = 10;
            const kmPerTile = 39.1; // At zoom 10, each tile = 39.1km at equator

            // Calculate target coverage - slightly larger than diameter for context
            const targetCoverageKm = config.radius * 2.2;

            // Calculate grid size needed at this fixed zoom level
            const tilesNeeded = Math.ceil(targetCoverageKm / kmPerTile);

            // Max grid: 63x63 (browser canvas limit 32k px / 512px tiles), min 5x5
            // 63 * 512px = 32,256px (within 32,767 limit)
            // At zoom 10: 63 tiles × 39.1km = 2,463km coverage = supports up to 1,119km radius
            let gridSize = Math.max(5, Math.min(63, tilesNeeded));
            if (gridSize % 2 === 0) gridSize++; // Make odd for centered grid

            const centerTile = latLonToTile(config.centerLat, config.centerLon, zoom);

            // Always use high-fidelity retina tiles (512px @2x) for accurate scale
            const tileSize = 512;

            // No canvas scaling - 1:1 to maintain accurate geographic scale matching aircraft
            const canvasScale = 1;
            const canvasSize = tileSize * gridSize;

            console.log('Map config:', {
                searchRadius: config.radius + 'km',
                targetCoverage: targetCoverageKm.toFixed(1) + 'km',
                actualCoverage: (gridSize * kmPerTile).toFixed(1) + 'km',
                zoom: zoom + ' (LOCKED)',
                kmPerTile: kmPerTile.toFixed(1) + ' km/tile',
                gridSize: gridSize + 'x' + gridSize,
                tileSize: tileSize + 'px @2x retina',
                canvasSize: canvasSize + 'px',
                totalTiles: gridSize * gridSize
            });

            // Calculate the actual lat/lon bounds of the tile grid
            const minTileX = centerTile.x - Math.floor(gridSize / 2);
            const maxTileX = centerTile.x + Math.floor(gridSize / 2) + 1;
            const minTileY = centerTile.y - Math.floor(gridSize / 2);
            const maxTileY = centerTile.y + Math.floor(gridSize / 2) + 1;

            const topLeft = tileToLatLon(minTileX, minTileY, zoom);
            const bottomRight = tileToLatLon(maxTileX, maxTileY, zoom);

            // Calculate 3D coordinates for corners
            const topLeftPos = latLonToCartesian(topLeft.lat, topLeft.lon, config.floorHeight);
            const bottomRightPos = latLonToCartesian(bottomRight.lat, bottomRight.lon, config.floorHeight);

            // Calculate plane width and height in 3D space
            const planeWidth = Math.abs(bottomRightPos.x - topLeftPos.x);
            const planeHeight = Math.abs(bottomRightPos.z - topLeftPos.z);
            const centerX = (topLeftPos.x + bottomRightPos.x) / 2;
            const centerZ = (topLeftPos.z + bottomRightPos.z) / 2;

            // Create high-resolution canvas to composite tiles
            const canvas = document.createElement('canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const ctx = canvas.getContext('2d', {
                alpha: false,
                desynchronized: false,
                willReadFrequently: false
            });

            // Enable image smoothing for better quality
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Fill with dark background first
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            let tilesLoaded = 0;
            const totalTiles = gridSize * gridSize;

            // Load tiles
            for (let dy = -Math.floor(gridSize / 2); dy <= Math.floor(gridSize / 2); dy++) {
                for (let dx = -Math.floor(gridSize / 2); dx <= Math.floor(gridSize / 2); dx++) {
                    const tileX = centerTile.x + dx;
                    const tileY = centerTile.y + dy;

                    // Build tile URL - always high-fidelity @2x retina tiles
                    const tileUrl = tileUrlTemplate
                        .replace('{z}', zoom)
                        .replace('{x}', tileX)
                        .replace('{y}', tileY)
                        .replace('.png', '@2x.png');

                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = function() {
                        // Check if this map load is still valid
                        if (thisToken !== mapLoadingToken) {
                            return; // Newer map request has been made, ignore this one
                        }

                        const canvasX = (dx + Math.floor(gridSize / 2)) * tileSize * canvasScale;
                        const canvasY = (dy + Math.floor(gridSize / 2)) * tileSize * canvasScale;

                        // Draw tile at full brightness
                        ctx.drawImage(img, canvasX, canvasY, tileSize * canvasScale, tileSize * canvasScale);

                        tilesLoaded++;
                        if (tilesLoaded === totalTiles) {
                            // Check again before rendering
                            if (thisToken !== mapLoadingToken) {
                                return; // Newer map request has been made, ignore this one
                            }

                            // All tiles loaded, create texture with high quality settings
                            const texture = new THREE.CanvasTexture(canvas);
                            texture.needsUpdate = true;

                            // Use linear filtering for best quality
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;

                            // Enable anisotropic filtering if available (up to 16x)
                            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                            texture.anisotropy = maxAnisotropy;

                            // Create plane geometry with correct scale
                            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                            const material = new THREE.MeshBasicMaterial({
                                map: texture,
                                transparent: false,
                                side: THREE.DoubleSide
                            });

                            mapPlane = new THREE.Mesh(geometry, material);
                            mapPlane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
                            mapPlane.position.set(centerX, -1, centerZ); // Position at tile grid center
                            scene.add(mapPlane);

                            console.log('Map loaded and positioned:', {
                                token: thisToken,
                                airportLocation: `(${config.centerLat.toFixed(4)}, ${config.centerLon.toFixed(4)})`,
                                airportIn3D: '(0, 0, 0) - world origin',
                                tileGridBounds: `(${topLeft.lat.toFixed(4)}, ${topLeft.lon.toFixed(4)}) to (${bottomRight.lat.toFixed(4)}, ${bottomRight.lon.toFixed(4)})`,
                                planeSize3D: `${planeWidth.toFixed(2)} x ${planeHeight.toFixed(2)}`,
                                planePosition3D: `(${centerX.toFixed(2)}, -1, ${centerZ.toFixed(2)})`,
                                offsetFromOrigin: `${Math.sqrt(centerX*centerX + centerZ*centerZ).toFixed(2)} units`,
                                scale: '1 tile = 39.1km (locked)',
                                anisotropy: maxAnisotropy
                            });
                        }
                    };
                    img.onerror = function() {
                        // Check if this map load is still valid
                        if (thisToken !== mapLoadingToken) {
                            return; // Newer map request has been made, ignore this one
                        }

                        tilesLoaded++;
                        console.warn(`Failed to load tile: ${tileUrl}`);
                        // If this was the last tile, still create the plane with what we have
                        if (tilesLoaded === totalTiles) {
                            // Check again before rendering
                            if (thisToken !== mapLoadingToken) {
                                return; // Newer map request has been made, ignore this one
                            }

                            const texture = new THREE.CanvasTexture(canvas);
                            texture.needsUpdate = true;

                            // Apply same high-quality texture settings
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                            texture.anisotropy = maxAnisotropy;

                            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                            const material = new THREE.MeshBasicMaterial({
                                map: texture,
                                transparent: false,
                                side: THREE.DoubleSide
                            });
                            mapPlane = new THREE.Mesh(geometry, material);
                            mapPlane.rotation.x = -Math.PI / 2;
                            mapPlane.position.set(centerX, -1, centerZ); // Position at tile grid center
                            scene.add(mapPlane);
                        }
                    };
                    img.src = tileUrl;
                }
            }
        }

        // Convert lat/lon to 3D coordinates
        function latLonToCartesian(lat, lon, altitude = 0) {
            // Center coordinates around origin
            const x = (lon - config.centerLon) * 111.32 * Math.cos(config.centerLat * Math.PI / 180);
            const z = -(lat - config.centerLat) * 111.32; // Negative Z for north
            // Subtract ground elevation so "ground" aircraft appear at y=0
            const y = (altitude - config.floorHeight) * config.altitudeScale / 1000;

            return new THREE.Vector3(x, y, z);
        }

        // Convert lat/lon to 3D coordinates with custom reference point
        function latLonToCartesianWithRef(lat, lon, altitude, refLat, refLon) {
            const x = (lon - refLon) * 111.32 * Math.cos(refLat * Math.PI / 180);
            const z = -(lat - refLat) * 111.32; // Negative Z for north
            const y = (altitude - config.floorHeight) * config.altitudeScale / 1000;
            return new THREE.Vector3(x, y, z);
        }

        // Flatten nested GeoJSON coordinates (handles Polygon and MultiPolygon)
        function flattenCoordinates(coords, result = []) {
            if (typeof coords[0] === 'number') {
                // Base case: [lon, lat] pair
                result.push(coords);
            } else {
                // Recursive case: array of coordinates
                for (let i = 0; i < coords.length; i++) {
                    flattenCoordinates(coords[i], result);
                }
            }
            return result;
        }

        // Get surface height at a specific lat/lon position (terrain or map)
        function getSurfaceHeightAt(lat, lon) {
            // Convert lat/lon to x/z position
            const x = (lon - config.centerLon) * 111.32 * Math.cos(config.centerLat * Math.PI / 180);
            const z = -(lat - config.centerLat) * 111.32;

            // Set up a raycast from high above downward
            const rayOrigin = new THREE.Vector3(x, 1000, z);
            const rayDirection = new THREE.Vector3(0, -1, 0); // Point downward
            raycaster.set(rayOrigin, rayDirection);

            // Check terrain first if enabled
            if (terrainEnabled && terrainGroup) {
                const intersects = raycaster.intersectObjects(terrainGroup.children, false);
                if (intersects.length > 0) {
                    return intersects[0].point.y;
                }
            }

            // Check map tiles if visible
            if (tilesGroup && tilesGroup.visible) {
                const intersects = raycaster.intersectObjects(tilesGroup.children, false);
                if (intersects.length > 0) {
                    return intersects[0].point.y;
                }
            }

            // No surface found, return null
            return null;
        }

        // Check if aircraft passes filters
        function passesFilters(ac) {
            // Callsign/Hex filter
            if (filters.callsign) {
                const search = filters.callsign.toUpperCase();
                const callsign = (ac.flight || '').trim().toUpperCase();
                const hex = (ac.hex || '').toUpperCase();
                if (!callsign.includes(search) && !hex.includes(search)) {
                    return false;
                }
            }

            // Type filter
            if (filters.type) {
                const search = filters.type.toUpperCase();
                const type = (ac.t || '').toUpperCase();
                if (!type.includes(search)) {
                    return false;
                }
            }

            // Ground filter
            const isGround = ac.alt_baro === 'ground';
            if (!filters.showGround && isGround) {
                return false;
            }

            // Altitude filters (only for airborne)
            if (!isGround) {
                const altitude = ac.alt_baro;
                if (filters.altitudeMin !== null && altitude < filters.altitudeMin) {
                    return false;
                }
                if (filters.altitudeMax !== null && altitude > filters.altitudeMax) {
                    return false;
                }
            }

            return true;
        }

        // Fetch aircraft data from airplanes.live API
        async function fetchAircraftData() {
            // Don't fetch live data during playback
            if (isPlayingBack) return;

            try {
                // Use followed aircraft position for search if in follow mode, otherwise use config center
                const searchLat = (followModeEnabled && followSearchLat !== null) ? followSearchLat : config.centerLat;
                const searchLon = (followModeEnabled && followSearchLon !== null) ? followSearchLon : config.centerLon;
                const url = `https://api.airplanes.live/v2/point/${searchLat}/${searchLon}/${config.radius * 0.539957}`; // Convert km to nautical miles

                const response = await fetch(url);
                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                if (data.ac && Array.isArray(data.ac)) {
                    const totalFetched = data.ac.length;
                    processAircraftData(data.ac);
                    updateStats(totalFetched);
                }
            } catch (error) {
                console.error('Error fetching aircraft data:', error);
            }
        }

        // ========== FLIGHT SEARCH FUNCTIONS ==========

        // Parse URL parameters for flight and airport search
        function parseURLParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const flightParam = urlParams.get('flight');
            const airportParam = urlParams.get('airport');

            // Flight takes priority over airport (if both are present)
            if (flightParam) {
                const callsign = flightParam.trim().toUpperCase();
                console.log(`🔍 URL parameter detected: ?flight=${callsign}`);

                // Wait for scene to initialize, then search
                setTimeout(() => {
                    document.getElementById('flight-search-input').value = callsign;
                    searchByCallsign(callsign);
                }, 2000);
            } else if (airportParam) {
                // Handle airport deep link
                handleAirportDeepLink();
            }
        }

        // Update URL parameter without page reload
        function updateURLParam(callsign) {
            const url = new URL(window.location);
            if (callsign) {
                url.searchParams.set('flight', callsign.toUpperCase());
                // Remove airport param (flight OR airport, not both)
                url.searchParams.delete('airport');
            } else {
                url.searchParams.delete('flight');
            }
            // Use replaceState instead of pushState to avoid browser history pollution
            window.history.replaceState({}, '', url);
        }

        // Update SEO meta tags for flight tracking
        function updateSEOTags(callsign, aircraftInfo) {
            if (callsign) {
                const title = `Tracking ${callsign} - Air Loom 3D Flight Tracker`;
                const description = aircraftInfo
                    ? `Track ${callsign} live in 3D. ${aircraftInfo.type || 'Aircraft'} at ${aircraftInfo.altitude !== 'ground' ? aircraftInfo.altitude + ' ft' : 'ground'}.`
                    : `Track flight ${callsign} live in real-time 3D visualization.`;

                document.title = title;

                // Update meta tags
                let metaDesc = document.querySelector('meta[name="description"]');
                if (metaDesc) metaDesc.content = description;

                let ogTitle = document.querySelector('meta[property="og:title"]');
                if (ogTitle) ogTitle.content = title;

                let ogDesc = document.querySelector('meta[property="og:description"]');
                if (ogDesc) ogDesc.content = description;

                let twitterTitle = document.querySelector('meta[name="twitter:title"]');
                if (twitterTitle) twitterTitle.content = title;

                let twitterDesc = document.querySelector('meta[name="twitter:description"]');
                if (twitterDesc) twitterDesc.content = description;
            } else {
                // Reset to default
                document.title = 'Air Loom - 3D Flight Paths';
            }
        }

        // Google Analytics custom event tracking
        // TODO: Add your Google Analytics Measurement ID in the <head> section
        // Example: gtag('config', 'G-XXXXXXXXXX');
        function trackGAEvent(eventName, params = {}) {
            if (typeof gtag === 'function') {
                gtag('event', eventName, params);
                console.log(`📊 GA Event: ${eventName}`, params);
            } else {
                console.log(`📊 GA Event (not configured): ${eventName}`, params);
            }
        }

        // Detect if input is a hex code or callsign
        function detectSearchType(input) {
            const cleaned = input.toUpperCase().trim();
            // ICAO hex codes are exactly 6 hexadecimal characters (0-9, A-F)
            const hexPattern = /^[0-9A-F]{6}$/;

            if (hexPattern.test(cleaned)) {
                return 'hex';
            }
            return 'callsign';
        }

        // Search for aircraft by callsign or hex using API
        async function searchByCallsign(input) {
            if (!input || input.length < 3) {
                showSearchStatus('error', 'Please enter at least 3 characters');
                return;
            }

            const searchBtn = document.getElementById('flight-search-btn');
            const searchInput = document.getElementById('flight-search-input');

            searchBtn.disabled = true;
            searchInput.disabled = true;

            // Detect search type
            const searchType = detectSearchType(input);
            const searchValue = input.toUpperCase().trim();
            const searchTypeLabel = searchType === 'hex' ? 'hex code' : 'callsign';

            // Track flight search
            trackGAEvent('flight_search', {
                'query': searchValue,
                'search_type': searchType
            });

            showSearchStatus('searching', `Searching for ${searchTypeLabel} ${searchValue}...`);

            try {
                // Step 1: Search using appropriate API endpoint based on input type
                const endpoint = searchType === 'hex' ? 'hex' : 'callsign';
                const searchUrl = `https://api.airplanes.live/v2/${endpoint}/${searchValue}`;
                console.log(`🔍 Searching ${searchType}: ${searchUrl}`);

                const response = await fetch(searchUrl);
                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                if (!data.ac || data.ac.length === 0) {
                    showSearchStatus('error', `${searchTypeLabel} ${searchValue} not found or not transmitting`);

                    // Track failed search
                    trackGAEvent('flight_search_failed', {
                        'query': searchValue,
                        'search_type': searchType,
                        'reason': 'not_found'
                    });

                    searchBtn.disabled = false;
                    searchInput.disabled = false;
                    return;
                }

                // Found aircraft - get first match
                const aircraft = data.ac[0];
                if (!aircraft.lat || !aircraft.lon) {
                    showSearchStatus('error', `${searchValue} found but no position data available`);

                    // Track failed search (no position)
                    trackGAEvent('flight_search_failed', {
                        'query': searchValue,
                        'search_type': searchType,
                        'reason': 'no_position'
                    });

                    searchBtn.disabled = false;
                    searchInput.disabled = false;
                    return;
                }

                // Get display name (prefer callsign, fallback to hex)
                const displayName = aircraft.flight?.trim() || aircraft.hex?.toUpperCase() || searchValue;
                console.log(`✈️ Found ${searchValue} (${displayName}) at ${aircraft.lat.toFixed(4)}, ${aircraft.lon.toFixed(4)}`);

                // Track successful search
                trackGAEvent('flight_search_success', {
                    'query': searchValue,
                    'search_type': searchType,
                    'callsign': aircraft.flight?.trim() || '',
                    'hex': aircraft.hex
                });

                // Step 2: Update location to center on aircraft
                const searchLat = aircraft.lat;
                const searchLon = aircraft.lon;
                // Use 0 for ground elevation - don't use aircraft altitude for floorHeight
                // The aircraft will render at its correct altitude when data loads
                const groundElevation = 0;

                // Change location to center on aircraft
                changeLocation(searchLat, searchLon, `Tracking ${displayName}`, groundElevation);

                // Step 3: Enable flight following after a short delay
                setTimeout(() => {
                    // Look for the aircraft in our data
                    const hex = aircraft.hex.toUpperCase();
                    if (aircraftData.has(hex)) {
                        followedAircraftHex = hex;
                        followModeEnabled = true;

                        // Update checkbox if it exists
                        const followCheckbox = document.getElementById('follow-aircraft');
                        if (followCheckbox) followCheckbox.checked = true;

                        // Update followed aircraft UI (enables share button)
                        updateFollowedAircraftUI();

                        // Update the aircraft label to show follow checkbox as checked and show share button
                        const data = aircraftData.get(hex);
                        if (data && data.label) {
                            // Recreate the label with updated follow state
                            data.label.remove();
                            data.label = createAircraftLabel(hex, data.info);
                        }

                        // Update URL and SEO (use callsign if available for better SEO)
                        const urlParam = aircraft.flight?.trim() || searchValue;
                        updateURLParam(urlParam);
                        updateSEOTags(urlParam, aircraftData.get(hex).info);

                        showSearchStatus('success', `Now tracking ${displayName}`);

                        console.log(`🎯 Now following ${displayName} (${hex})`);
                    } else {
                        showSearchStatus('success', `Centered on ${displayName} - waiting for data...`);
                        const urlParam = aircraft.flight?.trim() || searchValue;
                        updateURLParam(urlParam);
                        updateSEOTags(urlParam, null);
                    }
                }, 2000);

            } catch (error) {
                console.error('Search error:', error);
                showSearchStatus('error', 'Search failed - please try again');
            } finally {
                searchBtn.disabled = false;
                searchInput.disabled = false;
            }
        }

        // Show search status message
        function showSearchStatus(type, message) {
            const status = document.getElementById('search-status');
            status.className = `search-status ${type}`;
            status.textContent = message;
            status.style.display = 'block';

            // Auto-hide success/error messages after 5 seconds
            if (type !== 'searching') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 5000);
            }
        }

        // Share current followed flight
        async function shareCurrentFlight(buttonElement) {
            const shareUrl = window.location.href;
            let shareType, shareInfo;

            // Determine what we're sharing
            if (followedAircraftHex) {
                // Sharing a flight
                const data = aircraftData.get(followedAircraftHex);
                if (!data || !data.info) {
                    showSearchStatus('error', 'Aircraft data not available');
                    return;
                }
                shareType = 'flight';
                shareInfo = {
                    callsign: data.info.callsign || followedAircraftHex,
                    hex: followedAircraftHex
                };
            } else if (currentAirportCode) {
                // Sharing an airport
                const locationName = document.getElementById('location').textContent || currentAirportCode;
                shareType = 'airport';
                shareInfo = {
                    code: currentAirportCode,
                    name: locationName
                };
            } else {
                // Sharing the general map view (no specific selection)
                shareType = 'map';
                shareInfo = {
                    view: 'general'
                };
            }

            // Copy to clipboard
            try {
                await navigator.clipboard.writeText(shareUrl);

                // Update button text to show success
                if (buttonElement) {
                    const originalHTML = buttonElement.innerHTML;
                    buttonElement.innerHTML = '<span>✅</span><span>Link Copied!</span>';
                    buttonElement.disabled = true;

                    // Revert after 5 seconds
                    setTimeout(() => {
                        buttonElement.innerHTML = originalHTML;
                        buttonElement.disabled = false;
                    }, 5000);
                }

                // Track clipboard copy based on type
                if (shareType === 'flight') {
                    trackGAEvent('share_flight', {
                        'method': 'clipboard',
                        'callsign': shareInfo.callsign,
                        'hex': shareInfo.hex
                    });
                } else if (shareType === 'airport') {
                    trackGAEvent('share_airport', {
                        'method': 'clipboard',
                        'airport_code': shareInfo.code,
                        'airport_name': shareInfo.name
                    });
                } else {
                    trackGAEvent('share_map', {
                        'method': 'clipboard',
                        'view': 'general'
                    });
                }

                console.log(`✅ ${shareType === 'flight' ? 'Flight' : shareType === 'airport' ? 'Airport' : 'Map'} link copied to clipboard`);
            } catch (error) {
                console.error('Clipboard copy failed:', error);
                showSearchStatus('error', 'Failed to copy link. Please copy manually from address bar.');
            }
        }

        // ========== END FLIGHT SEARCH FUNCTIONS ==========

        // ========== AIRPORT SEARCH FUNCTIONS ==========

        // Global airport data cache
        let airportsDataCache = null;
        let airportsDataLoading = false;

        // Load and parse OurAirports CSV data
        async function loadAirportsData() {
            if (airportsDataCache) return airportsDataCache;
            if (airportsDataLoading) {
                // Wait for existing load to complete
                while (airportsDataLoading) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                return airportsDataCache;
            }

            airportsDataLoading = true;

            try {
                console.log('📦 Loading airports database from OurAirports...');
                const response = await fetch('https://davidmegginson.github.io/ourairports-data/airports.csv');
                if (!response.ok) throw new Error('Failed to fetch airports data');

                const csvText = await response.text();

                // Robust CSV parser
                function parseCSVLine(line) {
                    const fields = [];
                    let current = '';
                    let inQuotes = false;

                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        const nextChar = line[i + 1];

                        if (char === '"') {
                            if (inQuotes && nextChar === '"') {
                                // Escaped quote
                                current += '"';
                                i++; // Skip next quote
                            } else {
                                // Toggle quote state
                                inQuotes = !inQuotes;
                            }
                        } else if (char === ',' && !inQuotes) {
                            // End of field
                            fields.push(current);
                            current = '';
                        } else {
                            current += char;
                        }
                    }

                    // Add last field
                    fields.push(current);
                    return fields;
                }

                const lines = csvText.split('\n');
                const headers = parseCSVLine(lines[0]);

                // Find column indexes
                const getIndex = (name) => headers.findIndex(h => h.trim().toLowerCase() === name.toLowerCase());
                const identIdx = getIndex('ident');
                const typeIdx = getIndex('type');
                const nameIdx = getIndex('name');
                const latIdx = getIndex('latitude_deg');
                const lonIdx = getIndex('longitude_deg');
                const elevIdx = getIndex('elevation_ft');
                const isoCountryIdx = getIndex('iso_country');
                const municipalityIdx = getIndex('municipality');
                const iataIdx = getIndex('iata_code');
                const icaoIdx = getIndex('icao_code');
                const localCodeIdx = getIndex('local_code');

                const airports = [];

                // Parse CSV (skip header)
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const fields = parseCSVLine(line);
                    const getField = (idx) => fields[idx] ? fields[idx].trim() : '';

                    const type = getField(typeIdx);

                    const airport = {
                        ident: getField(identIdx),
                        type: type,
                        name: getField(nameIdx),
                        lat: parseFloat(getField(latIdx)),
                        lon: parseFloat(getField(lonIdx)),
                        elevation: parseInt(getField(elevIdx)) || 0,
                        country: getField(isoCountryIdx),
                        municipality: getField(municipalityIdx),
                        iata: getField(iataIdx),
                        icao: getField(icaoIdx),
                        localCode: getField(localCodeIdx)
                    };

                    // Must have valid coordinates
                    if (isNaN(airport.lat) || isNaN(airport.lon)) continue;

                    // Skip closed airports
                    if (type === 'closed') continue;

                    airports.push(airport);
                }

                airportsDataCache = airports;
                console.log(`✅ Loaded ${airports.length} airports`);
                return airports;

            } catch (error) {
                console.error('Error loading airports data:', error);
                throw error;
            } finally {
                airportsDataLoading = false;
            }
        }

        // ========== AIRCRAFT PHOTO FUNCTIONS ==========

        // Cache for aircraft photos to avoid duplicate API calls
        const aircraftPhotoCache = new Map(); // registration -> { image, link, photographer, timestamp }
        const PHOTO_CACHE_DURATION = 86400000; // 24 hours (per Planespotters.net API terms)

        // Fetch aircraft photo from Planespotters.net API
        async function fetchAircraftPhoto(registration, hexCode = null) {
            if (!registration && !hexCode) {
                return null;
            }

            // Prefer hex code lookup (more reliable and matches actual aircraft)
            const useHex = hexCode ? true : false;
            const cacheKey = hexCode || registration;
            const lookupValue = useHex ? hexCode.toUpperCase() : registration.trim().toUpperCase();

            // Check cache first
            const cached = aircraftPhotoCache.get(cacheKey);
            if (cached && (Date.now() - cached.timestamp < PHOTO_CACHE_DURATION)) {
                return cached;
            }

            try {
                console.log(`📸 Fetching photo for ${lookupValue} (${useHex ? 'hex' : 'reg'})...`);

                // Planespotters.net API - use hex code for more accurate results
                const endpoint = useHex
                    ? `https://api.planespotters.net/pub/photos/hex/${lookupValue}`
                    : `https://api.planespotters.net/pub/photos/reg/${lookupValue}`;

                const response = await fetch(endpoint);

                if (!response.ok) {
                    console.warn(`Failed to fetch photo for ${lookupValue}: ${response.status}`);
                    return null;
                }

                const data = await response.json();

                if (data.photos && data.photos.length > 0) {
                    const photoData = data.photos[0];
                    const photo = {
                        // Use larger thumbnail (280px) for better quality
                        image: photoData.thumbnail_large.src,
                        thumbnail: photoData.thumbnail.src, // Keep small one as backup
                        link: photoData.link,
                        photographer: photoData.photographer,
                        timestamp: Date.now()
                    };

                    // Cache the result
                    aircraftPhotoCache.set(cacheKey, photo);
                    console.log(`✅ Photo found for ${lookupValue}`);
                    return photo;
                } else {
                    console.log(`ℹ️ No photo available for ${lookupValue}`);
                    // Cache negative result too (with shorter duration)
                    aircraftPhotoCache.set(cacheKey, { noPhoto: true, timestamp: Date.now() });
                    return null;
                }
            } catch (error) {
                console.error(`Error fetching photo for ${lookupValue}:`, error);
                return null;
            }
        }

        // Update aircraft label with photo
        async function updateAircraftLabelPhoto(label, hex, registration = null) {
            const photoContainer = label.querySelector('.aircraft-photo-container');
            if (!photoContainer || !hex) return;

            // Show loading state
            photoContainer.innerHTML = '<div class="aircraft-photo-loading">⏳ Loading photo...</div>';

            // Use hex code for lookup (more reliable), fallback to registration if needed
            const photo = await fetchAircraftPhoto(registration, hex);
            const displayId = registration || hex;

            if (photo && !photo.noPhoto) {
                // Display photo (per Planespotters.net API terms: must attribute and link back)
                photoContainer.innerHTML = `
                    <a href="${photo.link}" target="_blank" rel="noopener">
                        <img src="${photo.image}" alt="Aircraft ${displayId}" loading="lazy">
                    </a>
                    <div class="aircraft-photo-credit">
                        © ${photo.photographer} |
                        <a href="${photo.link}" target="_blank" rel="noopener">Planespotters.net</a>
                    </div>
                `;
            } else {
                // No photo available
                photoContainer.innerHTML = '<div class="aircraft-photo-error">No photo available</div>';
            }
        }

        // ========== END AIRCRAFT PHOTO FUNCTIONS ==========

        // Filter airports based on search query
        function filterAirports(query, maxResults = 10) {
            if (!airportsDataCache || !query || query.length < 2) return [];

            const q = query.toUpperCase().trim();
            const scoredResults = [];

            // Search ALL airports and score them by relevance
            for (const airport of airportsDataCache) {
                let score = 0;
                let matched = false;

                // IATA code exact match (highest priority)
                if (airport.iata && airport.iata.toUpperCase() === q) {
                    score += 1000;
                    matched = true;
                }
                // IATA code starts with query
                else if (airport.iata && airport.iata.toUpperCase().startsWith(q)) {
                    score += 500;
                    matched = true;
                }
                // IATA code contains query
                else if (airport.iata && airport.iata.toUpperCase().includes(q)) {
                    score += 250;
                    matched = true;
                }

                // ICAO/ident code exact match
                if (airport.ident && airport.ident.toUpperCase() === q) {
                    score += 800;
                    matched = true;
                }
                // ICAO/ident starts with query
                else if (airport.ident && airport.ident.toUpperCase().startsWith(q)) {
                    score += 400;
                    matched = true;
                }
                // ICAO/ident contains query
                else if (airport.ident && airport.ident.toUpperCase().includes(q)) {
                    score += 200;
                    matched = true;
                }

                // Airport name starts with query
                if (airport.name && airport.name.toUpperCase().startsWith(q)) {
                    score += 300;
                    matched = true;
                }
                // Airport name contains query
                else if (airport.name && airport.name.toUpperCase().includes(q)) {
                    score += 100;
                    matched = true;
                }

                // Municipality (city) exact match
                if (airport.municipality && airport.municipality.toUpperCase() === q) {
                    score += 600;
                    matched = true;
                }
                // Municipality starts with query
                else if (airport.municipality && airport.municipality.toUpperCase().startsWith(q)) {
                    score += 350;
                    matched = true;
                }
                // Municipality contains query
                else if (airport.municipality && airport.municipality.toUpperCase().includes(q)) {
                    score += 150;
                    matched = true;
                }

                if (!matched) continue;

                // Boost score based on airport size/type
                if (airport.type === 'large_airport') {
                    score += 100;
                } else if (airport.type === 'medium_airport') {
                    score += 50;
                }

                // Boost if airport has IATA code (indicates commercial service)
                if (airport.iata && airport.iata.trim() !== '') {
                    score += 30;
                }

                scoredResults.push({ airport, score });
            }

            // Sort by score (highest first), then alphabetically by name
            scoredResults.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return (a.airport.name || '').localeCompare(b.airport.name || '');
            });

            // Return top results
            return scoredResults.slice(0, maxResults).map(r => r.airport);
        }

        // Show airport suggestions
        function showAirportSuggestions(suggestions) {
            const container = document.getElementById('airport-suggestions');

            if (suggestions.length === 0) {
                container.innerHTML = '<div class="airport-no-results">No airports found</div>';
                container.style.display = 'block';
                return;
            }

            container.innerHTML = suggestions.map(airport => {
                const code = airport.iata || airport.ident;
                const location = [airport.municipality, airport.country].filter(Boolean).join(', ');
                // Escape JSON for HTML attribute by encoding special characters
                const escapedAirport = JSON.stringify(airport).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                return `
                    <div class="airport-suggestion-item" data-airport="${escapedAirport}">
                        <div>
                            <span class="airport-code">${code}</span>
                            <span class="airport-name">${airport.name}</span>
                        </div>
                        ${location ? `<div class="airport-location">${location}</div>` : ''}
                    </div>
                `;
            }).join('');

            container.style.display = 'block';

            // Add click handlers
            container.querySelectorAll('.airport-suggestion-item').forEach(item => {
                item.addEventListener('click', () => {
                    // Decode HTML entities before parsing JSON
                    const encodedData = item.getAttribute('data-airport');
                    const decodedData = encodedData.replace(/&quot;/g, '"').replace(/&#39;/g, "'");
                    const airport = JSON.parse(decodedData);
                    selectAirport(airport);
                });
            });
        }

        // Hide airport suggestions
        function hideAirportSuggestions() {
            document.getElementById('airport-suggestions').style.display = 'none';
        }

        // Select an airport
        function selectAirport(airport) {
            const code = airport.iata || airport.ident;
            const input = document.getElementById('airport-search-input');

            // Update input value
            input.value = `${code} - ${airport.name}`;

            // Hide suggestions
            hideAirportSuggestions();

            // Center map on airport
            changeLocation(airport.lat, airport.lon, airport.name, airport.elevation, code);

            // Update URL (remove flight param if exists)
            updateAirportURLParam(code);

            // Update SEO tags
            updateAirportSEOTags(code, airport);

            console.log(`🛬 Selected airport: ${code} - ${airport.name}`);

            // Track airport selection
            trackGAEvent('airport_selected', {
                'airport_code': code,
                'airport_name': airport.name,
                'method': 'search'
            });
        }

        // Update URL parameter for airport
        function updateAirportURLParam(airportCode) {
            const url = new URL(window.location);
            if (airportCode) {
                url.searchParams.set('airport', airportCode.toUpperCase());
                // Remove flight param if it exists (airport OR flight, not both)
                url.searchParams.delete('flight');
            } else {
                url.searchParams.delete('airport');
            }
            window.history.replaceState({}, '', url);
        }

        // Update SEO meta tags for airport
        function updateAirportSEOTags(airportCode, airportInfo) {
            if (airportCode && airportInfo) {
                const city = airportInfo.municipality || airportCode;
                const title = `${airportCode} ${city} - Live 3D Flight Tracker | Air Loom`;
                const description = `Watch live flights around ${airportInfo.name} in real-time 3D. Track aircraft, view flight paths, and explore airspace around ${city}.`;

                document.title = title;

                // Update meta tags
                let metaDesc = document.querySelector('meta[name="description"]');
                if (metaDesc) metaDesc.content = description;

                let ogTitle = document.querySelector('meta[property="og:title"]');
                if (ogTitle) ogTitle.content = title;

                let ogDesc = document.querySelector('meta[property="og:description"]');
                if (ogDesc) ogDesc.content = description;

                let twitterTitle = document.querySelector('meta[name="twitter:title"]');
                if (twitterTitle) twitterTitle.content = title;

                let twitterDesc = document.querySelector('meta[name="twitter:description"]');
                if (twitterDesc) twitterDesc.content = description;

                let ogUrl = document.querySelector('meta[property="og:url"]');
                if (ogUrl) ogUrl.content = window.location.href;

                console.log(`📝 SEO updated for ${airportCode}`);
            } else {
                // Reset to default
                document.title = 'Air Loom - 3D Flight Paths';
            }
        }

        // Handle airport search from URL parameter
        async function handleAirportDeepLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const airportParam = urlParams.get('airport');

            if (airportParam) {
                const code = airportParam.trim().toUpperCase();
                console.log(`🔗 Airport deep link detected: ?airport=${code}`);

                try {
                    // Load airports data
                    const airports = await loadAirportsData();

                    // Find airport by code
                    const airport = airports.find(a =>
                        (a.iata && a.iata.toUpperCase() === code) ||
                        (a.ident && a.ident.toUpperCase() === code)
                    );

                    if (airport) {
                        // Wait for scene to initialize, then select airport
                        setTimeout(() => {
                            selectAirport(airport);
                        }, 2000);
                    } else {
                        console.warn(`Airport ${code} not found in database`);
                    }
                } catch (error) {
                    console.error('Error handling airport deep link:', error);
                }
            }
        }

        // ========== END AIRPORT SEARCH FUNCTIONS ==========

        // Process and store aircraft data
        function processAircraftData(aircraft) {
            const now = Date.now();
            const activeHexes = new Set();

            aircraft.forEach(ac => {
                if (!ac.lat || !ac.lon || !ac.hex) return;

                // If in remove mode, skip aircraft that don't pass filters
                if (filters.removeMode && !passesFilters(ac)) {
                    return;
                }

                const hex = ac.hex.toUpperCase();
                activeHexes.add(hex);

                // Determine altitude - for ground aircraft, try to snap to surface
                let altitude;
                if (ac.alt_baro !== 'ground') {
                    altitude = ac.alt_baro;
                } else {
                    // Get surface height at this position
                    const surfaceHeight = getSurfaceHeightAt(ac.lat, ac.lon);
                    if (surfaceHeight !== null) {
                        // Convert surface Y position back to altitude
                        altitude = config.floorHeight + (surfaceHeight * 1000 / config.altitudeScale);
                    } else {
                        // No surface found, use floor height
                        altitude = config.floorHeight;
                    }
                }

                const position = latLonToCartesian(ac.lat, ac.lon, altitude);

                if (!aircraftData.has(hex)) {
                    aircraftData.set(hex, {
                        positions: [],
                        lastUpdate: now,
                        info: {},
                        rawData: ac,
                        trail: null,
                        marker: null,
                        glow: null,
                        label: null
                    });
                }

                const data = aircraftData.get(hex);
                data.positions.push({
                    position,
                    timestamp: now,
                    altitude: altitude
                });

                // Keep only recent positions
                data.positions = data.positions.slice(-config.maxTrailLength);
                data.lastUpdate = now;
                data.rawData = ac;
                data.info = {
                    callsign: ac.flight?.trim() || hex,
                    registration: ac.r || '',
                    type: ac.t || '',
                    altitude: ac.alt_baro,
                    speed: ac.gs || 0,
                    track: ac.track || 0
                };
            });

            // Remove stale aircraft (not seen in last 2 minutes)
            for (const [hex, data] of aircraftData.entries()) {
                if (!activeHexes.has(hex) && now - data.lastUpdate > 120000) {
                    // Clean up visual objects
                    if (data.trail) {
                        trailGroup.remove(data.trail);
                        if (data.trail.geometry) data.trail.geometry.dispose();
                        if (data.trail.material) data.trail.material.dispose();
                        data.trail = null;
                    }
                    if (data.marker) {
                        aircraftGroup.remove(data.marker);
                        // Handle both single mesh and group markers (propeller aircraft)
                        if (data.marker.geometry) data.marker.geometry.dispose();
                        if (data.marker.material) data.marker.material.dispose();
                        if (data.marker.children && data.marker.children.length > 0) {
                            // Dispose children for THREE.Group markers
                            data.marker.children.forEach(child => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) child.material.dispose();
                            });
                        }
                        data.marker = null;
                    }
                    if (data.glow) {
                        aircraftGroup.remove(data.glow);
                        if (data.glow.geometry) data.glow.geometry.dispose();
                        if (data.glow.material) data.glow.material.dispose();
                        data.glow = null;
                    }
                    if (data.hitbox) {
                        aircraftGroup.remove(data.hitbox);
                        if (data.hitbox.geometry) data.hitbox.geometry.dispose();
                        if (data.hitbox.material) data.hitbox.material.dispose();
                        data.hitbox = null;
                    }
                    if (data.label) {
                        data.label.remove();
                        if (activeLabel === data.label) {
                            activeLabel = null;
                        }
                        if (expandedLabel === data.label) {
                            expandedLabel = null;
                        }
                        data.label = null;
                    }
                    aircraftData.delete(hex);
                }
            }

            updateVisuals();

            // Capture frame for recording if active
            if (isRecording) {
                captureFrame();
            }
        }

        // Update ground elevation using terrain elevation API
        async function updateGroundElevation(lat, lon) {
            try {
                // Use Open-Elevation API (free, no API key needed)
                const url = `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`;

                const response = await fetch(url);
                if (!response.ok) {
                    console.warn('Elevation API unavailable, keeping current elevation');
                    return;
                }

                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    const elevationMeters = data.results[0].elevation;
                    const elevationFeet = elevationMeters * 3.28084; // Convert meters to feet

                    config.floorHeight = Math.round(elevationFeet);
                    console.log(`🏔️ Ground elevation updated: ${config.floorHeight} ft at (${lat.toFixed(4)}, ${lon.toFixed(4)})`);
                }
            } catch (error) {
                console.warn('Error fetching ground elevation:', error);
            }
        }

        // Fetch airspace data from FAA ArcGIS API
        async function fetchAirspaceData() {
            if (!airspaceEnabled) return;

            const now = Date.now();
            if (now - lastAirspaceUpdate < AIRSPACE_UPDATE_INTERVAL && airspaceData.length > 0) {
                return; // Use cached data
            }

            try {
                // Use followed aircraft position if in follow mode, otherwise use config center
                const searchLat = (followModeEnabled && followSearchLat !== null) ? followSearchLat : config.centerLat;
                const searchLon = (followModeEnabled && followSearchLon !== null) ? followSearchLon : config.centerLon;

                // Calculate bounding box for query (expand search radius by 50% for better coverage)
                const expandedRadius = config.radius * 1.5;
                const latOffset = (expandedRadius / 111); // ~111 km per degree latitude
                const lonOffset = (expandedRadius / (111 * Math.cos(searchLat * Math.PI / 180)));

                const bbox = {
                    minLon: searchLon - lonOffset,
                    minLat: searchLat - latOffset,
                    maxLon: searchLon + lonOffset,
                    maxLat: searchLat + latOffset
                };

                // FAA Class Airspace GeoJSON API with spatial query
                const url = `https://services6.arcgis.com/ssFJjBXIUyZDrSYZ/arcgis/rest/services/Class_Airspace/FeatureServer/0/query?` +
                    `where=1%3D1&` +
                    `geometry=${bbox.minLon},${bbox.minLat},${bbox.maxLon},${bbox.maxLat}&` +
                    `geometryType=esriGeometryEnvelope&` +
                    `spatialRel=esriSpatialRelIntersects&` +
                    `outFields=*&` +
                    `returnGeometry=true&` +
                    `f=geojson`;

                const response = await fetch(url);
                if (!response.ok) {
                    console.warn('FAA Airspace API unavailable - no airspace will be shown');
                    airspaceData = [];
                } else {
                    const geojson = await response.json();
                    airspaceData = parseAirspaceGeoJSON(geojson);
                    console.log('Loaded real FAA airspace data');
                }

                lastAirspaceUpdate = now;
                renderAirspace();
                console.log(`Loaded ${airspaceData.length} airspace zones`);
                if (airspaceData.length > 0 && airspaceData.length < 5) {
                    console.log('Airspace zones:', airspaceData);
                }
            } catch (error) {
                console.error('Error fetching airspace data:', error);
                airspaceData = [];
                renderAirspace();
            }
        }

        // Parse FAA GeoJSON airspace data
        function parseAirspaceGeoJSON(geojson) {
            const zones = [];

            if (!geojson.features) return zones;

            geojson.features.forEach(feature => {
                const props = feature.properties;
                const geometry = feature.geometry;

                // Determine airspace class from properties
                let airspaceClass = props.CLASS || props.AIRSPACE_CLASS || 'E';
                if (airspaceClass.length > 1) {
                    airspaceClass = airspaceClass.charAt(0); // Get first character
                }

                // Extract floor and ceiling altitudes
                const floor = parseFloat(props.LOWER_VAL || props.FLOOR || 0);
                const ceiling = parseFloat(props.UPPER_VAL || props.CEILING || 10000);

                // Parse geometry - handle different types
                if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {
                    const coords = geometry.type === 'Polygon' ?
                        geometry.coordinates[0] :
                        geometry.coordinates[0][0];

                    // Calculate centroid and approximate radius
                    let sumLat = 0, sumLon = 0;
                    coords.forEach(coord => {
                        sumLon += coord[0];
                        sumLat += coord[1];
                    });
                    const centerLat = sumLat / coords.length;
                    const centerLon = sumLon / coords.length;

                    // Calculate average radius
                    let avgRadius = 0;
                    coords.forEach(coord => {
                        const dist = calculateDistance(centerLat, centerLon, coord[1], coord[0]);
                        avgRadius += dist;
                    });
                    avgRadius /= coords.length;

                    // Only add if it's a valid controlled airspace class
                    if (airspaceClass === 'B' || airspaceClass === 'C' || airspaceClass === 'D') {
                        zones.push({
                            type: airspaceClass,
                            lat: centerLat,
                            lon: centerLon,
                            radius: avgRadius,
                            floor: floor,
                            ceiling: ceiling,
                            name: props.NAME || props.IDENT || 'Airspace',
                            polygon: coords // Store actual polygon for better rendering
                        });
                    }
                }
            });

            return zones;
        }

        // Create airspace material with radius clipping
        function createAirspaceMaterial(airspaceType) {
            // Use ShaderMaterial with radius clipping like the terrain tiles
            const searchLat = (followModeEnabled && followSearchLat !== null) ? followSearchLat : config.centerLat;
            const searchLon = (followModeEnabled && followSearchLon !== null) ? followSearchLon : config.centerLon;

            const color = airspaceColors[airspaceType];
            const colorVec = new THREE.Color(color);

            return new THREE.ShaderMaterial({
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                uniforms: {
                    color: { value: colorVec },
                    opacity: { value: airspaceWireframeOnly ? 0.0 : airspaceOpacity },
                    emissiveIntensity: { value: 0.1 },
                    centerLat: { value: searchLat },
                    centerLon: { value: searchLon },
                    refLat: { value: config.centerLat },
                    refLon: { value: config.centerLon },
                    searchRadius: { value: config.radius }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float opacity;
                    uniform float emissiveIntensity;
                    uniform float centerLat;
                    uniform float centerLon;
                    uniform float refLat;
                    uniform float refLon;
                    uniform float searchRadius;
                    varying vec3 vWorldPosition;

                    #define PI 3.14159265359

                    void main() {
                        // Convert centerLat/centerLon to world coordinates
                        float centerX = (centerLon - refLon) * 111.32 * cos(refLat * PI / 180.0);
                        float centerZ = -(centerLat - refLat) * 111.32;
                        vec2 centerPos = vec2(centerX, centerZ);

                        // Calculate distance from search center
                        vec2 worldPos = vWorldPosition.xz;
                        float dist = length(worldPos - centerPos);

                        // Discard fragments outside search radius
                        if (dist > searchRadius) {
                            discard;
                        }

                        // Combine base color with emissive
                        vec3 finalColor = color + color * emissiveIntensity;
                        gl_FragColor = vec4(finalColor, opacity);
                    }
                `
            });
        }

        // Render airspace zones as 3D extruded shapes
        function renderAirspace() {
            // Clear existing airspace
            while (airspaceGroup.children.length > 0) {
                const child = airspaceGroup.children[0];
                airspaceGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            if (!airspaceEnabled) return;

            // Get current center position (either follow position or config center)
            const centerLat = (followModeEnabled && followSearchLat !== null) ? followSearchLat : config.centerLat;
            const centerLon = (followModeEnabled && followSearchLon !== null) ? followSearchLon : config.centerLon;

            airspaceData.forEach(zone => {
                // Only allow Class B, C, and D airspace - reject everything else
                if (zone.type !== 'B' && zone.type !== 'C' && zone.type !== 'D') return;

                // Filter out very low ceiling airspace (less than 1000 ft)
                if (zone.ceiling < 1000) return;

                // Check class filter
                if (zone.type === 'B' && !showClassB) return;
                if (zone.type === 'C' && !showClassC) return;
                if (zone.type === 'D' && !showClassD) return;

                // Focus radius filter - check if zone is within focus radius from current view center
                if (airspaceFocusOnly) {
                    const distanceKm = calculateDistance(centerLat, centerLon, zone.lat, zone.lon);
                    // Add zone radius to account for its size
                    const zoneRadius = zone.radius || 0;
                    if (distanceKm - zoneRadius > config.radius) {
                        return; // Zone is completely outside focus radius
                    }
                }

                // Check if airspace floor is below terrain surface
                if (terrainEnabled) {
                    const surfaceHeight = getSurfaceHeightAt(zone.lat, zone.lon);
                    if (surfaceHeight !== null) {
                        // Convert surface Y to altitude
                        const surfaceAltitude = config.floorHeight + (surfaceHeight * 1000 / config.altitudeScale);
                        // Hide airspace if its ceiling is below the terrain
                        if (zone.ceiling < surfaceAltitude) {
                            return;
                        }
                    }
                }

                // Respect floor and ceiling for wedding cake effect
                // Floor/ceiling are MSL, so subtract ground elevation to match aircraft coordinates
                const height = (zone.ceiling - zone.floor) * config.altitudeScale / 1000;
                const baseHeight = (zone.floor - config.floorHeight) * config.altitudeScale / 1000;

                let mesh;

                // Use polygon if available, otherwise cylinder
                if (zone.polygon && zone.polygon.length > 3) {
                    // Create extruded polygon shape
                    const shape = new THREE.Shape();

                    zone.polygon.forEach((coord, i) => {
                        const pos = latLonToCartesian(coord[1], coord[0], 0);
                        if (i === 0) {
                            shape.moveTo(pos.x, -pos.z);
                        } else {
                            shape.lineTo(pos.x, -pos.z);
                        }
                    });

                    const extrudeSettings = {
                        depth: height,
                        bevelEnabled: false
                    };

                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

                    // Create material with radius clipping
                    const material = createAirspaceMaterial(zone.type);

                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.y = baseHeight;
                    mesh.rotation.x = -Math.PI / 2; // Rotate to align with ground plane

                    // Add glowing wireframe outline
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: airspaceColors[zone.type],
                        transparent: true,
                        opacity: Math.min(airspaceOpacity + 0.3, 0.9),
                        linewidth: config.lineThickness
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    mesh.add(wireframe);

                } else {
                    // Fallback to cylinder for circular zones
                    const radiusInKm = zone.radius || 5;
                    const centerPos = latLonToCartesian(zone.lat, zone.lon, 0);

                    const geometry = new THREE.CylinderGeometry(
                        radiusInKm, radiusInKm, height, 48, 4, true
                    );

                    const material = createAirspaceMaterial(zone.type);

                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(centerPos.x, baseHeight + height / 2, centerPos.z);

                    // Vertical line markers every 90 degrees
                    for (let angle = 0; angle < 360; angle += 90) {
                        const rad = (angle * Math.PI) / 180;
                        const x = Math.cos(rad) * radiusInKm;
                        const z = Math.sin(rad) * radiusInKm;

                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(x, -height / 2, z),
                            new THREE.Vector3(x, height / 2, z)
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: airspaceColors[zone.type],
                            transparent: true,
                            opacity: airspaceOpacity + 0.2
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        mesh.add(line);
                    }
                }

                airspaceGroup.add(mesh);
            });

            console.log(`Rendered ${airspaceGroup.children.length} airspace zones`);
        }

        // Update airspace opacity
        function updateAirspaceOpacity(newOpacity) {
            airspaceOpacity = newOpacity;

            // Update all existing airspace materials
            airspaceGroup.children.forEach(child => {
                if (child.material) {
                    child.material.opacity = airspaceOpacity;
                }
            });
        }

        // Create floating label for aircraft
        function createAircraftLabel(hex, info) {
            const label = document.createElement('div');
            label.className = 'aircraft-info-label';
            label.dataset.hex = hex;

            const callsign = info.callsign || hex;
            const isFollowing = followedAircraftHex === hex;
            label.innerHTML = `
                <span class="label-callsign">${callsign}</span>
                <div class="label-details">
                    <div class="label-row">
                        <span class="label-key">Hex:</span>
                        <span class="label-val">${hex}</span>
                    </div>
                    <div class="label-row">
                        <span class="label-key">Reg:</span>
                        <span class="label-val">${info.registration || 'N/A'}</span>
                    </div>
                    <div class="label-row">
                        <span class="label-key">Type:</span>
                        <span class="label-val">${info.type || 'N/A'}</span>
                    </div>
                    <div class="label-row">
                        <span class="label-key">Alt:</span>
                        <span class="label-val">${info.altitude && info.altitude !== 'ground' ? info.altitude.toLocaleString() + ' ft' : 'Ground'}</span>
                    </div>
                    <div class="label-row">
                        <span class="label-key">Speed:</span>
                        <span class="label-val">${info.speed ? Math.round(info.speed) + ' kts' : 'N/A'}</span>
                    </div>
                    <div class="label-row">
                        <span class="label-key">Track:</span>
                        <span class="label-val">${info.track !== null && info.track !== undefined ? Math.round(info.track) + '°' : 'N/A'}</span>
                    </div>
                    <div class="label-tracking-controls" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="margin-bottom: 4px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px;">
                                <input type="checkbox" class="follow-toggle" ${isFollowing ? 'checked' : ''} style="margin-right: 6px;">
                                Follow This Aircraft
                            </label>
                        </div>
                        <div>
                            <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px;">
                                <input type="checkbox" class="surf-toggle" ${surfModeEnabled ? 'checked' : ''} style="margin-right: 6px;">
                                Surf Mode (auto-switch)
                            </label>
                        </div>
                        ${isFollowing ? `
                        <div style="margin-top: 8px;">
                            <button class="share-flight-btn" style="width: 100%; padding: 6px 10px; background: rgba(59, 130, 246, 0.8); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                <span>📤</span>
                                <span>Share This Flight</span>
                            </button>
                        </div>
                        ` : ''}
                    </div>
                    <div class="aircraft-photo-container"></div>
                </div>
            `;

            label.addEventListener('click', (e) => {
                e.stopPropagation();

                // If label is already shown but not expanded, expand it
                if (label.style.display !== 'none' && !label.classList.contains('expanded')) {
                    // Collapse other expanded labels
                    if (expandedLabel && expandedLabel !== label) {
                        expandedLabel.classList.remove('expanded');
                    }
                    label.classList.add('expanded');
                    expandedLabel = label;

                    // Fetch and display aircraft photo when expanded
                    // Use hex code for lookup (more reliable than registration)
                    updateAircraftLabelPhoto(label, hex, info.registration);
                }
            });

            // Add event listeners for tracking controls
            const followToggle = label.querySelector('.follow-toggle');
            const surfToggle = label.querySelector('.surf-toggle');

            if (followToggle) {
                followToggle.addEventListener('change', (e) => {
                    e.stopPropagation();
                    if (e.target.checked) {
                        // Enable following for this aircraft
                        followedAircraftHex = hex;
                        updateFollowedAircraftUI();
                        console.log(`✈️ Now following aircraft: ${callsign}`);

                        // Update URL for sharing (without page reload or history entry)
                        const urlParam = callsign || hex;
                        updateURLParam(urlParam);

                        // Update SEO tags for social sharing
                        const data = aircraftData.get(hex);
                        updateSEOTags(urlParam, data ? data.info : null);

                        // Track analytics event
                        trackGAEvent('follow_aircraft', {
                            'method': 'click',
                            'callsign': callsign || 'N/A',
                            'hex': hex
                        });

                        // Dynamically add share button to the label
                        const trackingControls = label.querySelector('.label-tracking-controls');
                        if (trackingControls && !label.querySelector('.share-flight-btn')) {
                            const shareButtonDiv = document.createElement('div');
                            shareButtonDiv.style.marginTop = '8px';
                            shareButtonDiv.innerHTML = `
                                <button class="share-flight-btn" style="width: 100%; padding: 6px 10px; background: rgba(59, 130, 246, 0.8); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                    <span>📤</span>
                                    <span>Share This Flight</span>
                                </button>
                            `;
                            trackingControls.appendChild(shareButtonDiv);

                            // Add event listener to the new share button
                            const newShareBtn = shareButtonDiv.querySelector('.share-flight-btn');
                            if (newShareBtn) {
                                newShareBtn.addEventListener('click', (evt) => {
                                    evt.stopPropagation();
                                    shareCurrentFlight(newShareBtn);
                                });
                            }
                        }
                    } else {
                        // Disable following
                        if (followedAircraftHex === hex) {
                            followedAircraftHex = null;
                            updateFollowedAircraftUI();
                            console.log(`✈️ Stopped following aircraft`);

                            // Remove URL parameter
                            updateURLParam(null);

                            // Track analytics event
                            trackGAEvent('unfollow_aircraft', {
                                'callsign': callsign || 'N/A',
                                'hex': hex
                            });

                            // Remove share button from label
                            const shareBtn = label.querySelector('.share-flight-btn');
                            if (shareBtn && shareBtn.parentElement) {
                                shareBtn.parentElement.remove();
                            }

                            // Re-render airspace if focus mode is enabled (to update back to original center)
                            if (airspaceEnabled && airspaceFocusOnly) {
                                renderAirspace();
                            }
                        }
                    }
                });
            }

            if (surfToggle) {
                surfToggle.addEventListener('change', (e) => {
                    e.stopPropagation();
                    surfModeEnabled = e.target.checked;
                    console.log(`🏄 Surf Mode ${surfModeEnabled ? 'enabled' : 'disabled'}`);
                    // Update the main surf mode checkbox in the menu
                    const mainSurfToggle = document.getElementById('surf-mode');
                    if (mainSurfToggle) {
                        mainSurfToggle.checked = surfModeEnabled;
                    }
                });
            }

            // Add event listener for share button
            const shareBtn = label.querySelector('.share-flight-btn');
            if (shareBtn) {
                shareBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    shareCurrentFlight(shareBtn);
                });
            }

            label.style.display = 'none'; // Hidden by default
            document.body.appendChild(label);
            return label;
        }

        // Update label content with latest aircraft data
        function updateLabelContent(label, info) {
            if (!label || !info) return;

            // Update only the dynamic values (altitude, speed, track)
            const altElement = label.querySelector('.label-row:nth-child(4) .label-val');
            const speedElement = label.querySelector('.label-row:nth-child(5) .label-val');
            const trackElement = label.querySelector('.label-row:nth-child(6) .label-val');

            if (altElement) {
                altElement.textContent = info.altitude && info.altitude !== 'ground'
                    ? info.altitude.toLocaleString() + ' ft'
                    : 'Ground';
            }
            if (speedElement) {
                speedElement.textContent = info.speed
                    ? Math.round(info.speed) + ' kts'
                    : 'N/A';
            }
            if (trackElement) {
                trackElement.textContent = info.track !== null && info.track !== undefined
                    ? Math.round(info.track) + '°'
                    : 'N/A';
            }
        }

        // Update label position based on 3D position
        function updateLabelPosition(label, position3D) {
            const vector = position3D.clone();
            vector.project(camera);

            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

            label.style.left = x + 'px';
            label.style.top = y + 'px';

            // Hide label if behind camera
            label.style.display = vector.z < 1 ? 'block' : 'none';
        }

        // Update 3D visuals
        function updateVisuals() {
            clickableObjects.length = 0;

            // Update or create visuals for each aircraft
            aircraftData.forEach((data, hex) => {
                // Need at least 1 position to show marker, 2+ for trails
                if (data.positions.length < 1) {
                    // Hide if no position data at all
                    if (data.trail) data.trail.visible = false;
                    if (data.marker) data.marker.visible = false;
                    if (data.glow) data.glow.visible = false;
                    if (data.label && activeLabel === data.label) {
                        data.label.style.display = 'none';
                        activeLabel = null;
                        expandedLabel = null;
                    }
                    return;
                }

                // Hide trails for aircraft with only 1 position (need 2 points for a line)
                if (data.positions.length < 2 && data.trail) {
                    data.trail.visible = false;
                }

                // Check if passes filters (only matters in hide mode)
                const shouldShow = filters.removeMode ? true : passesFilters(data.rawData);

                // Hide label if aircraft is filtered out
                if (!shouldShow && data.label && activeLabel === data.label) {
                    data.label.style.display = 'none';
                    activeLabel = null;
                    expandedLabel = null;
                }

                // Create or update label
                if (!data.label) {
                    data.label = createAircraftLabel(hex, data.info);
                } else {
                    // Update label content if info changed
                    const callsign = data.info.callsign || hex;
                    data.label.querySelector('.label-callsign').textContent = callsign;
                }

                // Create trail ribbon (only if we have 2+ positions for a curve)
                let curve, points;
                if (data.positions.length >= 2) {
                    const positions = data.positions.map(p => p.position);
                    curve = new THREE.CatmullRomCurve3(positions);

                    // LOD: Calculate distance-based point count for performance
                    const distanceToCamera = data.marker ? camera.position.distanceTo(data.marker.position) : 0;
                    let maxTrailPoints;

                    if (hex === followedAircraftHex) {
                        // Always use full detail for followed aircraft
                        maxTrailPoints = 200;
                    } else if (distanceToCamera < 100) {
                        maxTrailPoints = 200; // High detail (0-100 units)
                    } else if (distanceToCamera < 300) {
                        maxTrailPoints = 75;  // Medium detail (100-300 units)
                    } else if (distanceToCamera < 600) {
                        maxTrailPoints = 30;  // Low detail (300-600 units)
                    } else {
                        maxTrailPoints = 15;  // Very low detail (600+ units)
                    }

                    points = curve.getPoints(Math.min(positions.length * 5, maxTrailPoints));
                }

                // Color based on altitude or speed (or white if followed aircraft)
                let color;
                if (hex === followedAircraftHex) {
                    // Followed aircraft: white/bright highlight
                    color = new THREE.Color(0xFFFFFF);
                } else if (colorMode === 'speed') {
                    // Color by speed (0-600 knots typical range)
                    const speed = data.info?.speed || 0;
                    const hue = Math.min(speed / 600, 1) * 0.6; // 0 (red) to 0.6 (cyan)
                    color = new THREE.Color().setHSL(hue, 1, 0.5);
                } else {
                    // Color by altitude (default)
                    const avgAltitude = Math.max(data.positions.reduce((sum, p) => sum + p.altitude, 0) / data.positions.length, 100);
                    const hue = Math.min(avgAltitude / 40000, 1) * 0.6; // 0 (red) to 0.6 (cyan)
                    color = new THREE.Color().setHSL(hue, 1, 0.5);
                }

                // Skip trail rendering for ground aircraft
                const isGroundAircraft = data.rawData && data.rawData.alt_baro === 'ground';

                if (isGroundAircraft) {
                    // Hide/remove trail for ground aircraft
                    if (data.trail) {
                        data.trail.visible = false;
                    }
                } else {
                    // Update or create trail for flying aircraft (only if we have 2+ positions)
                    if (points && data.positions.length >= 2) {
                        const useThickLines = config.lineThickness > 1;

                        if (data.trail) {
                            // Check if we need to switch line types
                            const isThickLine = data.trail.isLine2 || false;

                            if (useThickLines !== isThickLine) {
                                // Need to recreate trail with different line type
                                data.trail.geometry.dispose();
                                data.trail.material.dispose();
                                trailGroup.remove(data.trail);
                                data.trail = null;
                            } else {
                                // Update existing trail
                                data.trail.geometry.dispose();

                                if (useThickLines) {
                                    // Update Line2
                                    const positions = points.flatMap(p => [p.x, p.y, p.z]);
                                    const geometry = new LineGeometry();
                                    geometry.setPositions(positions);
                                    data.trail.geometry = geometry;
                                    data.trail.material.color.set(color);
                                    data.trail.material.linewidth = config.lineThickness;
                                } else {
                                    // Update Line
                                    data.trail.geometry = new THREE.BufferGeometry().setFromPoints(points);
                                    data.trail.material.color.set(color);
                                }
                                data.trail.visible = shouldShow;
                            }
                        }

                    if (!data.trail) {
                    // Create new trail
                    if (useThickLines) {
                        // Create Line2 for thick lines
                        const positions = points.flatMap(p => [p.x, p.y, p.z]);
                        const geometry = new LineGeometry();
                        geometry.setPositions(positions);
                        const material = new LineMaterial({
                            color: color,
                            linewidth: config.lineThickness,
                            transparent: true,
                            opacity: 0.8,
                            resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                        });
                        data.trail = new Line2(geometry, material);
                        data.trail.computeLineDistances();
                    } else {
                        // Create standard Line for thin lines
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color,
                            transparent: true,
                            opacity: 0.8
                        });
                        data.trail = new THREE.Line(geometry, material);
                    }
                    data.trail.visible = shouldShow;
                    trailGroup.add(data.trail);
                }
                    } // End of if (points && data.positions.length >= 2)
                } // End of else block for flying aircraft

                const currentPos = data.positions[data.positions.length - 1].position;

                // Calculate pitch and bank BEFORE updating/creating marker (so they apply to ALL aircraft)
                let pitchRotation = 0;
                let bankRotation = 0;
                let lastTrackValue = null;

                // PITCH (rotation.x): Angle up/down based on average position change
                if (data.positions.length >= 2) {
                    // Use last several points for smoother pitch calculation
                    const numPoints = Math.min(5, data.positions.length); // Use up to last 5 points
                    const startIdx = data.positions.length - numPoints;

                    // Get first and last position in the range
                    const startPos = data.positions[startIdx].position;
                    const endPos = data.positions[data.positions.length - 1].position;

                    // Calculate total horizontal distance (x, z plane)
                    const dx = endPos.x - startPos.x;
                    const dz = endPos.z - startPos.z;
                    const horizontalDist = Math.sqrt(dx * dx + dz * dz);

                    // Calculate total vertical distance (rise)
                    const dy = endPos.y - startPos.y;

                    // Calculate pitch angle: arctan(rise / run)
                    // Only calculate if there's meaningful horizontal movement (> 0.05 km)
                    if (horizontalDist > 0.05) {
                        const pitchAngle = Math.atan(dy / horizontalDist);

                        // Allow more pronounced pitch (±25 degrees = ±0.436 radians)
                        // Negate because positive rotation.x pitches nose down in Three.js
                        pitchRotation = Math.max(-0.436, Math.min(0.436, -pitchAngle));
                    }
                }

                // BANK (rotation.z): Roll into turns
                if (data.rawData && data.rawData.track !== undefined) {
                    if (data.marker && data.marker.userData.lastTrack !== undefined) {
                        const currentTrack = data.rawData.track;
                        const lastTrack = data.marker.userData.lastTrack;

                        // Calculate turn rate (handle 360° wraparound)
                        let turnRate = currentTrack - lastTrack;
                        if (turnRate > 180) turnRate -= 360;
                        if (turnRate < -180) turnRate += 360;

                        // Bank angle proportional to turn rate (exaggerated for visibility)
                        const bankAngle = turnRate * 5 * (Math.PI / 180);

                        // Limit bank to ±30 degrees
                        bankRotation = Math.max(-0.523, Math.min(0.523, bankAngle));

                        lastTrackValue = currentTrack;
                    } else {
                        // Initialize lastTrack for first time
                        lastTrackValue = data.rawData.track;
                        bankRotation = 0;
                    }
                }

                // Update or create marker
                if (data.marker) {
                    data.marker.position.copy(currentPos);

                    // Update color - handle mesh, LOD, and group markers
                    if (data.marker.material) {
                        // Single mesh marker
                        data.marker.material.color = color;
                    } else if (data.marker.isLOD) {
                        // LOD marker - update all LOD levels
                        data.marker.children.forEach(child => {
                            if (child.material && child.material.color) {
                                child.material.color = color;
                            }
                        });
                    } else if (data.marker.children && data.marker.children.length > 0) {
                        // Group marker (propeller aircraft) - update all children
                        data.marker.children.forEach(child => {
                            if (child.material && child.material.color) {
                                child.material.color = color;
                            }
                        });
                    }

                    data.marker.userData = { hex, info: data.info };
                    data.marker.visible = shouldShow;

                    // Set rotation order: Y (heading) first, then X (pitch), then Z (bank)
                    // This ensures pitch/bank are applied in aircraft's local frame, not world frame
                    data.marker.rotation.order = 'YXZ';

                    // HEADING (rotation.y): Point nose in direction of travel
                    if (data.rawData && data.rawData.track !== undefined && data.rawData.track !== null) {
                        // Track is 0° = North, 90° = East, 180° = South, 270° = West
                        // In Three.js: +Z = South, -Z = North, +X = East, -X = West
                        // So we need to convert: rotation.y = (180 - track) in radians
                        data.marker.rotation.y = (180 - data.rawData.track) * (Math.PI / 180);
                    }

                    // Apply calculated pitch and bank
                    data.marker.rotation.x = pitchRotation;
                    data.marker.rotation.z = bankRotation;
                    if (lastTrackValue !== null) {
                        data.marker.userData.lastTrack = lastTrackValue;
                    }
                } else {
                    // OPTIMIZATION: Use aircraft-specific geometry based on type with LOD
                    const aircraftGeometry = getAircraftGeometry(data.rawData);

                    // Check if geometry includes separate propellers/rotors
                    if (aircraftGeometry.body && aircraftGeometry.props) {
                        // Aircraft with propellers/rotors - create as group with separate meshes
                        // TODO: Add LOD support for helicopters/props in future update
                        data.marker = new THREE.Group();

                        const markerMaterial = new THREE.MeshBasicMaterial({
                            color,
                            depthWrite: true,
                            depthTest: true
                        });

                        // Main body mesh (opaque)
                        const bodyMesh = new THREE.Mesh(aircraftGeometry.body, markerMaterial);
                        data.marker.add(bodyMesh);

                        // Propeller/rotor mesh (50% transparent)
                        const propMaterial = new THREE.MeshBasicMaterial({
                            color,
                            transparent: true,
                            opacity: 0.5,
                            depthWrite: false,  // Prevent z-fighting
                            depthTest: true,
                            side: THREE.DoubleSide  // Make rotors visible from all angles
                        });
                        const propMesh = new THREE.Mesh(aircraftGeometry.props, propMaterial);
                        data.marker.add(propMesh);
                    } else {
                        // Simple geometry (jets, balloons, etc.) - use LOD for performance
                        data.marker = createAircraftLOD(aircraftGeometry, 'jet');

                        // Apply color to all LOD levels
                        data.marker.children.forEach(child => {
                            if (child.material) {
                                child.material.color = color;
                                child.material.depthWrite = true;
                                child.material.depthTest = true;
                            }
                        });
                    }

                    data.marker.position.copy(currentPos);
                    data.marker.userData = { hex, info: data.info };
                    data.marker.visible = shouldShow;

                    // Set rotation order: Y (heading) first, then X (pitch), then Z (bank)
                    // This ensures pitch/bank are applied in aircraft's local frame, not world frame
                    data.marker.rotation.order = 'YXZ';

                    // Set initial rotations
                    if (data.rawData) {
                        // HEADING (rotation.y)
                        if (data.rawData.track !== undefined && data.rawData.track !== null) {
                            data.marker.rotation.y = (180 - data.rawData.track) * (Math.PI / 180);
                        }
                    }

                    // Apply calculated pitch and bank (same as existing markers)
                    data.marker.rotation.x = pitchRotation;
                    data.marker.rotation.z = bankRotation;
                    if (lastTrackValue !== null) {
                        data.marker.userData.lastTrack = lastTrackValue;
                    }

                    aircraftGroup.add(data.marker);
                }

                // Update or create glow (using Sprite with circular texture)
                if (data.glow) {
                    data.glow.position.copy(currentPos);
                    data.glow.material.color = color;
                    data.glow.visible = shouldShow;
                } else {
                    // Use Sprite with circular gradient texture for realistic halos
                    const glowMaterial = new THREE.SpriteMaterial({
                        map: glowCircleTexture,
                        color,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending, // Makes it glow nicely
                        sizeAttenuation: true // Scale with distance
                    });
                    data.glow = new THREE.Sprite(glowMaterial);
                    data.glow.scale.set(2.5, 2.5, 1); // Slightly larger for better visibility
                    data.glow.position.copy(currentPos);
                    data.glow.visible = shouldShow;
                    aircraftGroup.add(data.glow);
                }

                // Update or create invisible hitbox for easier clicking/tapping
                if (data.hitbox) {
                    data.hitbox.position.copy(currentPos);
                    data.hitbox.userData = { hex, info: data.info };
                } else {
                    // Larger hitbox on mobile for easier tapping (invisible)
                    const hitboxSize = isMobileDevice ? 3 : 1.5;
                    const hitboxGeometry = new THREE.SphereGeometry(hitboxSize, 8, 8);
                    const hitboxMaterial = new THREE.MeshBasicMaterial({
                        visible: false // Invisible but still raycastable
                    });
                    data.hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                    data.hitbox.position.copy(currentPos);
                    data.hitbox.userData = { hex, info: data.info };
                    aircraftGroup.add(data.hitbox);
                }

                // Add invisible hitbox to clickable objects (larger touch area)
                if (shouldShow && data.hitbox) {
                    clickableObjects.push(data.hitbox);
                }
            });

        }

        // Update statistics
        function updateStats(totalCount) {
            let visibleCount;
            if (filters.removeMode) {
                // In remove mode, visible count = aircraft in memory (already filtered)
                visibleCount = aircraftData.size;
            } else {
                // In hide mode, count aircraft that pass filters
                visibleCount = Array.from(aircraftData.values()).filter(data =>
                    data.rawData && passesFilters(data.rawData)
                ).length;
            }

            // Update UI
            document.getElementById('aircraft-count').textContent = totalCount;
            document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
        }

        // Change location (airport or GPS)
        function changeLocation(lat, lon, name, elevation = 0, airportCode = null) {
            config.centerLat = lat;
            config.centerLon = lon;
            config.elevation = elevation;
            config.floorHeight = elevation;

            // Update UI
            document.getElementById('location').textContent = name;
            document.getElementById('gps-elevation').textContent = elevation + ' ft';
            document.getElementById('floor-height').value = elevation;
            document.getElementById('floor-height-value').textContent = elevation;

            // Reset camera
            camera.position.set(0, 50, 100);
            if (!isFlyMode) {
                orbitControls.target.set(0, 0, 0);
                orbitControls.update();
            }

            // Clear all visual objects from scene
            while (trailGroup.children.length > 0) {
                const child = trailGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                trailGroup.remove(child);
            }

            while (aircraftGroup.children.length > 0) {
                const child = aircraftGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                aircraftGroup.remove(child);
            }

            // Clear labels
            aircraftData.forEach((data) => {
                if (data.label) {
                    data.label.remove();
                }
            });

            // Clear aircraft data
            aircraftData.clear();
            clickableObjects.length = 0;
            activeLabel = null;
            expandedLabel = null;

            // Fetch new aircraft data (skip during playback)
            if (!isPlayingBack) {
                fetchAircraftData();
            }

            // Clear and reload airspace data for new location
            if (airspaceEnabled) {
                airspaceData = []; // Clear old data
                lastAirspaceUpdate = 0; // Reset cache timestamp to force fresh fetch
                renderAirspace(); // Clear visual airspace immediately
                fetchAirspaceData(); // Fetch new airspace for this location
            }

            // Update airport label if airport code provided
            if (airportCode) {
                currentAirportCode = airportCode;
                if (airportLabelEnabled) {
                    createAirportLabel(airportCode);
                }
            } else {
                // Clear airport label when using GPS location
                currentAirportCode = null;
                if (currentAirportLabel) {
                    scene.remove(currentAirportLabel);
                    if (currentAirportLabel.geometry) currentAirportLabel.geometry.dispose();
                    if (currentAirportLabel.material) currentAirportLabel.material.dispose();
                    currentAirportLabel = null;
                }
            }

            // Clear old tiles and load new ones for this location
            if (currentMapLayer !== 'none') {
                // Clear ALL existing tiles first
                for (const tileKey of loadedTiles.keys()) {
                    unloadTile(tileKey);
                }
                // Now load tiles for new location
                updateVisibleTiles(config.centerLat, config.centerLon, config.radius, currentMapLayer);
            }

            // Clear and reload terrain tiles for new location
            if (terrainEnabled) {
                for (const tileKey of loadedTerrainTiles.keys()) {
                    unloadTerrainTile(tileKey);
                }
                updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);
            }

            // Clear and reload boundaries for new location
            if (showBoundaries) {
                clearBoundaries();
                loadWorldBoundaries(boundaryResolution);
            }

            console.log('Location changed to:', name, lat, lon, 'elevation:', elevation);
        }

        // Load font for 3D text
        function loadFont() {
            if (loadedFont) return Promise.resolve(loadedFont);

            fontLoader = new FontLoader();
            return new Promise((resolve, reject) => {
                fontLoader.load(
                    'https://threejs.org/examples/fonts/helvetiker_bold.typeface.json',
                    (font) => {
                        loadedFont = font;
                        resolve(font);
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading font:', error);
                        reject(error);
                    }
                );
            });
        }

        // Get display text for airport
        function getAirportDisplayText(airportCode) {
            const airport = airports[airportCode];
            if (!airport) return airportCode;

            if (labelShowFullName) {
                // Use city name if available, otherwise extract from name
                return airport.city || airport.name.split(' - ')[1] || airportCode;
            } else {
                // Use displayCode if available, otherwise use the code itself
                return airport.displayCode || airportCode;
            }
        }

        // Create 3D airport label
        async function createAirportLabel(airportCode) {
            // Remove existing label
            if (currentAirportLabel) {
                scene.remove(currentAirportLabel);
                if (currentAirportLabel.geometry) currentAirportLabel.geometry.dispose();
                if (currentAirportLabel.material) currentAirportLabel.material.dispose();
                currentAirportLabel = null;
            }

            if (!airportLabelEnabled || !airportCode) return;

            currentAirportCode = airportCode;

            try {
                // Load font if not loaded
                const font = await loadFont();

                // Get text to display
                const displayText = getAirportDisplayText(airportCode);

                // Create text geometry
                const textGeometry = new TextGeometry(displayText, {
                    font: font,
                    size: 8,
                    height: 0.5,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelSegments: 5
                });

                // Center the geometry
                textGeometry.computeBoundingBox();
                const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);

                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5,
                    metalness: 0.1,
                    roughness: 0.4
                });

                const textMesh = new THREE.Mesh(textGeometry, textMaterial);

                // Position northeast of origin (airport location)
                if (labelStanding) {
                    // Standing upright
                    textMesh.position.set(30 + centerOffset, 4, -30); // Northeast, elevated
                    textMesh.rotation.x = 0; // Standing upright
                } else {
                    // Laying flat
                    textMesh.position.set(30 + centerOffset, 0.5, -30); // Northeast, slightly above ground
                    textMesh.rotation.x = -Math.PI / 2; // Flat on the ground
                }

                currentAirportLabel = textMesh;
                scene.add(textMesh);

                console.log(`Created 3D label for airport: ${displayText} (${labelStanding ? 'standing' : 'flat'})`);
            } catch (error) {
                console.error('Error creating airport label:', error);
            }
        }

        // Toggle airport label visibility
        function toggleAirportLabel(enabled) {
            airportLabelEnabled = enabled;
            if (enabled && currentAirportCode) {
                createAirportLabel(currentAirportCode);
            } else if (currentAirportLabel) {
                scene.remove(currentAirportLabel);
                if (currentAirportLabel.geometry) currentAirportLabel.geometry.dispose();
                if (currentAirportLabel.material) currentAirportLabel.material.dispose();
                currentAirportLabel = null;
            }
        }

        // Create branding text
        async function createBrandingLabel() {
            try {
                // Load font if not loaded
                const font = await loadFont();

                // Create text geometry
                const textGeometry = new TextGeometry('Made by Veer V .6', {
                    font: font,
                    size: 3,
                    height: 0.3,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.05,
                    bevelSize: 0.05,
                    bevelSegments: 3
                });

                // Center the geometry
                textGeometry.computeBoundingBox();
                const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);

                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.3,
                    metalness: 0.1,
                    roughness: 0.4,
                    transparent: true,
                    opacity: 0.6
                });

                const textMesh = new THREE.Mesh(textGeometry, textMaterial);

                // Position at bottom south of scene
                textMesh.position.set(centerOffset, 0.3, 80); // South, slightly above ground
                textMesh.rotation.x = -Math.PI / 2; // Flat on the ground

                brandingLabel = textMesh;
                scene.add(textMesh);

                console.log('Created branding label');
            } catch (error) {
                console.error('Error creating branding label:', error);
            }
        }

        // Load random US airport as default
        function loadRandomUSAirport() {
            // Get all US airport codes
            const usAirportCodes = [
                'ABQ', 'ANC', 'ATL', 'AUS', 'BDL', 'BNA', 'BOS', 'BUR', 'BWI',
                'CLE', 'CLT', 'CMH', 'CVG', 'DAL', 'DCA', 'DEN', 'DFW', 'DSM', 'DTW',
                'ELP', 'EWR', 'FLL', 'HNL', 'HOU', 'IAD', 'IAH', 'IND', 'JAX',
                'JFK', 'LAS', 'LAX', 'LGA', 'MCI', 'MCO', 'MDW', 'MEM', 'MIA',
                'MKE', 'MSP', 'MSY', 'OAK', 'OKC', 'ONT', 'ORD', 'PBI', 'PDX',
                'PHL', 'PHX', 'PIT', 'PVD', 'RDU', 'RNO', 'RSW', 'SAN', 'SAT',
                'SEA', 'SFO', 'SJC', 'SLC', 'SMF', 'SNA', 'STL', 'TPA', 'TUS'
            ];

            // Pick random airport
            const randomCode = usAirportCodes[Math.floor(Math.random() * usAirportCodes.length)];
            const airport = airports[randomCode];

            // Load that airport
            changeLocation(airport.lat, airport.lon, airport.name, airport.elevation, randomCode);

            // Update search input to show selected airport
            document.getElementById('airport-search-input').value = `${randomCode} - ${airport.name}`;

            console.log(`Loaded random airport: ${randomCode}`);
        }

        // Get user location
        function getUserLocation() {
            // Track GPS location request
            trackGAEvent('gps_location_requested', {});

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const gpsElevation = position.coords.altitude !== null && position.coords.altitude !== 0
                            ? Math.round(position.coords.altitude * 3.28084)
                            : 0;

                        changeLocation(
                            position.coords.latitude,
                            position.coords.longitude,
                            'GPS Location',
                            gpsElevation
                        );

                        // Clear airport search input
                        document.getElementById('airport-search-input').value = '';

                        // Track successful GPS location
                        trackGAEvent('gps_location_success', {
                            'has_altitude': gpsElevation > 0
                        });
                    },
                    error => {
                        console.log('Geolocation error, loading random US airport', error);

                        // Track GPS error
                        trackGAEvent('gps_location_error', {
                            'error_code': error.code,
                            'error_message': error.message
                        });

                        loadRandomUSAirport();
                    },
                    { enableHighAccuracy: true }
                );
            } else {
                console.log('Geolocation not supported, loading random US airport');

                // Track geolocation not supported
                trackGAEvent('gps_location_error', {
                    'error_message': 'not_supported'
                });

                loadRandomUSAirport();
            }
        }

        // Update followed aircraft UI
        function updateFollowedAircraftUI() {
            const info = document.getElementById('followed-aircraft-info');
            const nameSpan = document.getElementById('followed-aircraft-name');
            const shareBtn = document.getElementById('menu-share-flight-btn');

            if (followedAircraftHex) {
                const data = aircraftData.get(followedAircraftHex);
                if (data && data.info) {
                    const name = data.info.flight || data.info.registration || followedAircraftHex;
                    nameSpan.textContent = name;
                    info.style.display = 'block';
                } else {
                    nameSpan.textContent = followedAircraftHex;
                    info.style.display = 'block';
                }

                // Enable share button (following flight)
                if (shareBtn) {
                    shareBtn.disabled = false;
                    shareBtn.style.cursor = 'pointer';
                    shareBtn.style.opacity = '1';
                    shareBtn.style.background = 'rgba(59, 130, 246, 0.8)';

                    // Update button text
                    const textSpan = shareBtn.querySelector('span:last-child');
                    if (textSpan) textSpan.textContent = 'Share Current Flight';
                }
            } else {
                info.style.display = 'none';

                // Enable share button if at an airport, otherwise disable
                if (shareBtn) {
                    if (currentAirportCode) {
                        // Enable for airport sharing
                        shareBtn.disabled = false;
                        shareBtn.style.cursor = 'pointer';
                        shareBtn.style.opacity = '1';
                        shareBtn.style.background = 'rgba(59, 130, 246, 0.8)';

                        // Update button text
                        const textSpan = shareBtn.querySelector('span:last-child');
                        if (textSpan) textSpan.textContent = 'Share Current Airport';
                    } else {
                        // Enable for general map view sharing
                        shareBtn.disabled = false;
                        shareBtn.style.cursor = 'pointer';
                        shareBtn.style.opacity = '1';
                        shareBtn.style.background = 'rgba(59, 130, 246, 0.8)';

                        // Update button text for map view
                        const textSpan = shareBtn.querySelector('span:last-child');
                        if (textSpan) textSpan.textContent = 'Share Current View';
                    }
                }
            }
        }

        // SURF MODE: Auto-select next aircraft
        function selectNextAircraftForSurfing() {
            if (!surfModeEnabled || !followModeEnabled) {
                return false;
            }

            // Get all available aircraft
            const availableAircraft = [];
            for (const [hex, data] of aircraftData.entries()) {
                // Skip if no valid data or not visible
                if (!data || !data.rawData || !data.marker || !data.marker.visible) {
                    continue;
                }

                // NEVER pick aircraft on the ground
                const ac = data.rawData;

                // Skip if altitude is too low (< 1000ft = likely landing/taking off or on ground)
                if (ac.alt_baro != null && ac.alt_baro < 1000) {
                    continue;
                }
                if (ac.alt_geom != null && ac.alt_geom < 1000) {
                    continue;
                }

                // Skip if groundspeed is too low (< 80 knots = likely taxiing or stationary)
                if (ac.gs != null && ac.gs < 80) {
                    continue;
                }

                // Skip if vertical rate indicates it's on the ground (no climb/descent)
                // AND altitude/speed are marginal
                if (ac.baro_rate != null && Math.abs(ac.baro_rate) < 64 &&
                    ac.alt_baro != null && ac.alt_baro < 2000 &&
                    ac.gs != null && ac.gs < 100) {
                    continue; // Likely cruising very low or on ground
                }

                availableAircraft.push(hex);
            }

            if (availableAircraft.length === 0) {
                // Check if we recently jumped to an airport (waiting for aircraft to load)
                const timeSinceJump = Date.now() - surfModeAirportJumpTime;
                if (surfModeWaitingForAircraft && timeSinceJump < SURF_MODE_AIRPORT_DELAY) {
                    console.log(`🏄 Surf Mode: Waiting ${((SURF_MODE_AIRPORT_DELAY - timeSinceJump) / 1000).toFixed(1)}s for aircraft to load...`);
                    return true; // Still waiting, don't jump again yet
                }

                console.log('🏄 Surf Mode: No aircraft available in current area');

                // Pick a random airport and jump there
                const airportCodes = Object.keys(airports);
                if (airportCodes.length > 0) {
                    const randomAirportCode = airportCodes[Math.floor(Math.random() * airportCodes.length)];
                    const airport = airports[randomAirportCode];

                    console.log(`🏄 Surf Mode: Jumping to random airport ${airport.name} (${randomAirportCode}), waiting for aircraft...`);

                    // Change location to the new airport
                    changeLocation(airport.lat, airport.lon, airport.name, airport.elevation, randomAirportCode);

                    // Clear followed aircraft and set waiting flag
                    followedAircraftHex = null;
                    updateFollowedAircraftUI();
                    surfModeWaitingForAircraft = true;
                    surfModeAirportJumpTime = Date.now();

                    return true; // Successfully handled surf mode
                }

                console.log('🏄 Surf Mode: No airports available to jump to');
                return false;
            }

            // Aircraft are available! Clear waiting flag
            surfModeWaitingForAircraft = false;

            // Pick a random aircraft
            const randomIndex = Math.floor(Math.random() * availableAircraft.length);
            const nextHex = availableAircraft[randomIndex];

            // Select it
            followedAircraftHex = nextHex;
            updateFollowedAircraftUI();

            const nextData = aircraftData.get(nextHex);
            const name = (nextData && nextData.info) ?
                (nextData.info.flight || nextData.info.registration || nextHex) : nextHex;

            console.log(`🏄 Surf Mode: Auto-switched to ${name} (${availableAircraft.length} aircraft available)`);
            return true;
        }

        // Update follow mode (called every frame)
        function updateFollowMode() {
            if (!followModeEnabled) {
                followSearchLat = null;
                followSearchLon = null;
                return;
            }

            // SURF MODE: If no aircraft is followed but surf mode is on, try to auto-select one
            if (!followedAircraftHex && surfModeEnabled) {
                // Don't call selectNextAircraftForSurfing() too frequently while waiting for aircraft to load
                // Only call if: (1) not waiting, OR (2) enough time has passed to check for aircraft
                const timeSinceJump = Date.now() - surfModeAirportJumpTime;
                if (!surfModeWaitingForAircraft || timeSinceJump >= SURF_MODE_AIRPORT_DELAY) {
                    selectNextAircraftForSurfing();
                }
                return; // Let next frame handle the newly selected aircraft
            }

            if (!followedAircraftHex) {
                followSearchLat = null;
                followSearchLon = null;
                return;
            }

            const data = aircraftData.get(followedAircraftHex);
            if (!data || !data.rawData || !data.marker) {
                // Aircraft lost - DO NOT update config.center to prevent trail breaks
                // Search will continue at last known position via followSearchLat/followSearchLon

                // SURF MODE: Grace period before switching to another aircraft
                if (surfModeEnabled) {
                    // Start grace period timer if this is the first time we noticed it's lost
                    if (surfModeLastFollowedHex !== followedAircraftHex) {
                        surfModeAircraftLostTime = Date.now();
                        surfModeLastFollowedHex = followedAircraftHex;
                        console.log(`✈️ Aircraft lost - waiting ${SURF_MODE_LOST_GRACE_PERIOD/1000}s to reconnect...`);
                    }

                    // Check if grace period has elapsed
                    const timeSinceLost = Date.now() - surfModeAircraftLostTime;
                    if (timeSinceLost < SURF_MODE_LOST_GRACE_PERIOD) {
                        // Still within grace period - keep trying to reconnect to same aircraft
                        // Log only once per second to avoid spam
                        if (Math.floor(timeSinceLost / 1000) !== Math.floor((timeSinceLost - 16) / 1000)) {
                            console.log(`🏄 Surf Mode: Waiting for aircraft to return (${((SURF_MODE_LOST_GRACE_PERIOD - timeSinceLost) / 1000).toFixed(0)}s remaining)...`);
                        }
                        return; // Don't clear, give it time to come back
                    }

                    // Grace period expired - try to select next aircraft
                    console.log(`🏄 Surf Mode: Grace period expired, switching to next aircraft...`);
                    const surfedToNext = selectNextAircraftForSurfing();
                    if (surfedToNext) {
                        // Successfully surfed to next aircraft - reset grace period tracking
                        surfModeAircraftLostTime = 0;
                        surfModeLastFollowedHex = null;
                        return;
                    }
                }

                // No surf mode or no aircraft available - clear everything
                if (followSearchLat !== null && followSearchLon !== null) {
                    console.log(`✈️ Aircraft lost at position: ${followSearchLat.toFixed(4)}, ${followSearchLon.toFixed(4)}`);
                }

                followedAircraftHex = null;
                updateFollowedAircraftUI();
                lastFollowSearchLat = null;
                lastFollowSearchLon = null;
                followSearchLat = null;
                followSearchLon = null;
                lastMapCenterLat = null; // Reset map tracking
                lastMapCenterLon = null;
                surfModeAircraftLostTime = 0; // Reset grace period
                surfModeLastFollowedHex = null;

                // Re-render airspace if focus mode is enabled (to update back to original center)
                if (airspaceEnabled && airspaceFocusOnly) {
                    renderAirspace();
                }

                return;
            }

            // Aircraft found - reset grace period tracking if it was lost before
            if (surfModeLastFollowedHex === followedAircraftHex && surfModeAircraftLostTime > 0) {
                const timeSinceLost = Date.now() - surfModeAircraftLostTime;
                console.log(`✈️ Aircraft reconnected after ${(timeSinceLost / 1000).toFixed(1)}s!`);
                surfModeAircraftLostTime = 0;
                surfModeLastFollowedHex = null;
            }

            const ac = data.rawData;

            // Update camera to follow aircraft marker position
            if (data.marker && data.marker.visible) {
                const aircraftPos = data.marker.position;

                // Update orbit controls target to aircraft position
                if (!isFlyMode && orbitControls) {
                    orbitControls.target.copy(aircraftPos);
                    orbitControls.update();
                }
            }

            // Track aircraft position for search updates (only during live mode)
            if (ac.lat != null && ac.lon != null && !isPlayingBack) {
                followSearchLat = ac.lat;
                followSearchLon = ac.lon;

                // Check if aircraft moved significantly (> 5km) to trigger new search
                if (lastFollowSearchLat !== null && lastFollowSearchLon !== null) {
                    const latDiff = Math.abs(ac.lat - lastFollowSearchLat);
                    const lonDiff = Math.abs(ac.lon - lastFollowSearchLon);
                    const distKm = Math.sqrt(
                        Math.pow(latDiff * 111.32, 2) +
                        Math.pow(lonDiff * 111.32 * Math.cos(ac.lat * Math.PI / 180), 2)
                    );

                    if (distKm > 5) {
                        // Aircraft moved significantly, reload aircraft data
                        console.log(`✈️ Follow mode: Aircraft moved ${distKm.toFixed(1)}km, updating search...`);
                        lastFollowSearchLat = ac.lat;
                        lastFollowSearchLon = ac.lon;
                        fetchAircraftData();

                        // Re-render airspace if focus mode is enabled (to update visible airspace based on new position)
                        if (airspaceEnabled && airspaceFocusOnly) {
                            renderAirspace();
                        }
                    }
                } else {
                    lastFollowSearchLat = ac.lat;
                    lastFollowSearchLon = ac.lon;

                    // Initial follow - re-render airspace if focus mode is enabled
                    if (airspaceEnabled && airspaceFocusOnly) {
                        renderAirspace();
                    }
                }

                // Update shader uniforms EVERY FRAME for circular mask (in focused mode)
                // This must run every frame, not just when reloading tiles, so the mask follows the aircraft smoothly
                if (focusedTilesMode) {
                    // Update map tile shaders to follow aircraft
                    for (const [tileKey, tile] of loadedTiles.entries()) {
                        if (tile.material && tile.material.uniforms) {
                            if (tile.material.uniforms.centerLat) {
                                tile.material.uniforms.centerLat.value = ac.lat;
                            }
                            if (tile.material.uniforms.centerLon) {
                                tile.material.uniforms.centerLon.value = ac.lon;
                            }
                            // Ensure reference point is set (stays at airport origin)
                            if (tile.material.uniforms.refLat) {
                                tile.material.uniforms.refLat.value = config.centerLat;
                            }
                            if (tile.material.uniforms.refLon) {
                                tile.material.uniforms.refLon.value = config.centerLon;
                            }
                        }
                    }
                    // Update terrain tile shaders to follow aircraft
                    for (const [tileKey, tile] of loadedTerrainTiles.entries()) {
                        if (tile.material && tile.material.uniforms) {
                            if (tile.material.uniforms.centerLat) {
                                tile.material.uniforms.centerLat.value = ac.lat;
                            }
                            if (tile.material.uniforms.centerLon) {
                                tile.material.uniforms.centerLon.value = ac.lon;
                            }
                            // Ensure reference point is set (stays at airport origin)
                            if (tile.material.uniforms.refLat) {
                                tile.material.uniforms.refLat.value = config.centerLat;
                            }
                            if (tile.material.uniforms.refLon) {
                                tile.material.uniforms.refLon.value = config.centerLon;
                            }
                        }
                    }

                    // Update airspace shaders to follow aircraft
                    airspaceGroup.children.forEach(airspace => {
                        if (airspace.material && airspace.material.uniforms) {
                            if (airspace.material.uniforms.centerLat) {
                                airspace.material.uniforms.centerLat.value = ac.lat;
                            }
                            if (airspace.material.uniforms.centerLon) {
                                airspace.material.uniforms.centerLon.value = ac.lon;
                            }
                        }
                    });
                }

                // PROGRESSIVE MAP LOADING for Flight Following
                // Check if aircraft moved significantly from last map center (percentage-based threshold)
                if (currentMapLayer !== 'none') {
                    let shouldReloadMap = false;

                    if (lastMapCenterLat === null || lastMapCenterLon === null) {
                        // First time - load map at aircraft position
                        shouldReloadMap = true;
                        console.log(`🗺️ Flight Following: Initial map load at aircraft position`);
                    } else {
                        // Calculate distance from last map center
                        const latDiff = Math.abs(ac.lat - lastMapCenterLat);
                        const lonDiff = Math.abs(ac.lon - lastMapCenterLon);
                        const distFromMapCenterKm = Math.sqrt(
                            Math.pow(latDiff * 111.32, 2) +
                            Math.pow(lonDiff * 111.32 * Math.cos(ac.lat * Math.PI / 180), 2)
                        );

                        // Adaptive threshold: reload when aircraft moves 30% of search radius
                        const mapUpdateThresholdKm = config.radius * mapUpdateThresholdPercent;

                        if (distFromMapCenterKm > mapUpdateThresholdKm) {
                            shouldReloadMap = true;
                            console.log(`🗺️ Flight Following: Aircraft moved ${distFromMapCenterKm.toFixed(1)}km from map center (threshold: ${mapUpdateThresholdKm.toFixed(0)}km), reloading map...`);
                        }
                    }

                    if (shouldReloadMap) {
                        // Update map center tracking
                        lastMapCenterLat = ac.lat;
                        lastMapCenterLon = ac.lon;

                        // DO NOT update config.centerLat/centerLon - keeps origin fixed
                        // This prevents trails from breaking when origin moves
                        // Search radius follows via followSearchLat/followSearchLon
                        // 3D space can be unlimited - aircraft just moves far from origin

                        // Reload map tiles centered at aircraft position
                        updateVisibleTiles(ac.lat, ac.lon, config.radius, currentMapLayer);

                        // Also reload terrain tiles if enabled
                        if (terrainEnabled) {
                            updateVisibleTerrainTiles(ac.lat, ac.lon, config.radius);
                        }

                        // Reload airspace data along flight path
                        if (airspaceEnabled) {
                            lastAirspaceUpdate = 0; // Force airspace refresh
                            fetchAirspaceData();
                        }

                        console.log(`🗺️ Flight Following: Map reloaded at (${ac.lat.toFixed(4)}, ${ac.lon.toFixed(4)})`);
                    }
                }
            }
        }


        // Handle clicks on aircraft markers
        function onAircraftClick(event) {
            // Ignore clicks on UI elements
            if (event.target.closest('#menu-panel, #menu-toggle, .aircraft-info-label')) {
                return;
            }

            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections with aircraft markers
            const intersects = raycaster.intersectObjects(clickableObjects);

            if (intersects.length > 0) {
                const clickedMarker = intersects[0].object;
                const hex = clickedMarker.userData.hex;
                const data = aircraftData.get(hex);

                // Just show the label - user must click "Follow" checkbox to actually follow
                if (data && data.label) {
                    // Hide previous active label
                    if (activeLabel && activeLabel !== data.label) {
                        activeLabel.style.display = 'none';
                        activeLabel.classList.remove('expanded');
                    }

                    // Show this label (compact)
                    data.label.style.display = 'block';
                    data.label.classList.remove('expanded');
                    activeLabel = data.label;
                    expandedLabel = null;
                }
            } else {
                // Clicked elsewhere - hide all labels
                if (activeLabel) {
                    activeLabel.style.display = 'none';
                    activeLabel.classList.remove('expanded');
                    activeLabel = null;
                    expandedLabel = null;
                }
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update follow mode (tracks aircraft position)
            updateFollowMode();

            // Update label positions (only for active label)
            if (activeLabel) {
                // Find the aircraft data for active label
                for (const [hex, data] of aircraftData.entries()) {
                    if (data.label === activeLabel && data.marker && data.marker.visible) {
                        updateLabelPosition(data.label, data.marker.position);
                        updateLabelContent(data.label, data.info);
                        break;
                    }
                }
            }

            // Update controls based on mode
            if (isFlyMode) {
                // Handle fly mode movement
                if (flyControls.isLocked) {
                    direction.z = Number(keyboard.forward) - Number(keyboard.backward);
                    direction.x = Number(keyboard.right) - Number(keyboard.left);
                    direction.y = Number(keyboard.up) - Number(keyboard.down);
                    direction.normalize();

                    if (keyboard.forward || keyboard.backward) {
                        velocity.z = direction.z * moveSpeed;
                    } else {
                        velocity.z = 0;
                    }

                    if (keyboard.left || keyboard.right) {
                        velocity.x = direction.x * moveSpeed;
                    } else {
                        velocity.x = 0;
                    }

                    if (keyboard.up || keyboard.down) {
                        velocity.y = direction.y * moveSpeed;
                    } else {
                        velocity.y = 0;
                    }

                    flyControls.moveRight(velocity.x);
                    flyControls.moveForward(velocity.z);

                    // Manual vertical movement
                    camera.position.y += velocity.y;
                }
            } else {
                orbitControls.update();
            }

            // Check if view center or zoom changed - retile if needed (with debouncing and throttling)
            if (currentMapLayer !== 'none') {
                const currentViewCenter = getCameraViewCenter();
                const currentVisibleRadius = getVisibleRadius();

                // Initialize on first run
                if (lastVisibleRadius === 0) {
                    lastViewCenter = currentViewCenter;
                    lastVisibleRadius = currentVisibleRadius;
                }

                // Calculate how far the view center moved (panning/scrolling)
                const viewCenterMoveDistance = calculateDistance(
                    lastViewCenter.lat, lastViewCenter.lon,
                    currentViewCenter.lat, currentViewCenter.lon
                );

                // Calculate zoom change (visible radius change)
                const radiusChangeRatio = Math.abs(currentVisibleRadius - lastVisibleRadius) / lastVisibleRadius;

                // Check if retiling thresholds are met
                const shouldRetile = viewCenterMoveDistance > VIEW_CENTER_MOVE_THRESHOLD ||
                                     radiusChangeRatio > VISIBLE_RADIUS_CHANGE_THRESHOLD;

                if (shouldRetile) {
                    // Camera is moving - cancel any pending debounce timer
                    if (retileDebounceTimer) {
                        clearTimeout(retileDebounceTimer);
                    }

                    // Mark that we need to retile
                    pendingRetile = true;

                    // Set up debounced retile (wait for camera to stop moving)
                    retileDebounceTimer = setTimeout(() => {
                        // Check if minimum time has passed since last retile
                        const timeSinceLastRetile = Date.now() - lastRetileTime;
                        if (timeSinceLastRetile >= MIN_RETILE_INTERVAL_MS) {
                            console.log(`🔄 Retiling (debounced): view moved ${viewCenterMoveDistance.toFixed(1)}km, zoom changed ${(radiusChangeRatio * 100).toFixed(1)}%`);

                            updateVisibleTiles(config.centerLat, config.centerLon, config.radius, currentMapLayer);
                            updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);

                            lastViewCenter = currentViewCenter;
                            lastVisibleRadius = currentVisibleRadius;
                            lastRetileTime = Date.now();
                            pendingRetile = false;
                        } else {
                            // Too soon - wait a bit more
                            const waitTime = MIN_RETILE_INTERVAL_MS - timeSinceLastRetile;
                            console.log(`⏳ Retile throttled, waiting ${waitTime}ms`);
                            retileDebounceTimer = setTimeout(() => {
                                updateVisibleTiles(config.centerLat, config.centerLon, config.radius, currentMapLayer);
                                updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);

                                lastViewCenter = currentViewCenter;
                                lastVisibleRadius = currentVisibleRadius;
                                lastRetileTime = Date.now();
                                pendingRetile = false;
                            }, waitTime);
                        }
                    }, RETILE_DEBOUNCE_MS);
                }
            }

            // Update compass rotation to always point north
            if (compassEnabled) {
                const compassInner = document.getElementById('compass-inner');
                if (compassInner) {
                    // Calculate camera azimuth (horizontal rotation)
                    const dx = camera.position.x - orbitControls.target.x;
                    const dz = camera.position.z - orbitControls.target.z;
                    const azimuth = Math.atan2(dx, dz);
                    const degrees = azimuth * (180 / Math.PI);

                    // Rotate compass inner group so north marker always points north
                    compassInner.setAttribute('transform', `rotate(${degrees} 50 50)`);
                }
            }

            // Update LOD levels for aircraft markers using batched updates for performance
            // Only update a percentage of aircraft per frame instead of all
            const aircraftArray = Array.from(aircraftData.entries());
            const totalAircraft = aircraftArray.length;

            if (totalAircraft > 0) {
                const batchSize = Math.max(1, Math.ceil(totalAircraft * LOD_UPDATE_PERCENTAGE));

                for (let i = 0; i < batchSize; i++) {
                    const idx = (lodUpdateOffset + i) % totalAircraft;
                    const [hex, data] = aircraftArray[idx];

                    if (data.marker && data.marker.isLOD) {
                        // Distance-based culling: hide aircraft beyond 20000 units
                        const distToCamera = camera.position.distanceTo(data.marker.position);

                        // Check if aircraft should be visible based on filters
                        const shouldShow = filters.removeMode ? true : passesFilters(data.rawData);

                        if (distToCamera > 20000) {
                            // Beyond max distance - hide everything
                            data.marker.visible = false;
                            if (data.trail) data.trail.visible = false;
                            if (data.glow) data.glow.visible = false;
                        } else {
                            // Within range - update LOD and restore visibility if passes filters
                            data.marker.update(camera);
                            data.marker.visible = shouldShow;
                            if (data.trail) data.trail.visible = shouldShow;
                            if (data.glow) data.glow.visible = shouldShow;
                        }
                    }
                }

                // Advance offset for next frame
                lodUpdateOffset = (lodUpdateOffset + batchSize) % totalAircraft;
            }

            renderer.render(scene, camera);
        }

        // Keyboard event handlers
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    keyboard.forward = true;
                    break;
                case 'KeyA':
                    keyboard.left = true;
                    break;
                case 'KeyS':
                    keyboard.backward = true;
                    break;
                case 'KeyD':
                    keyboard.right = true;
                    break;
                case 'Space':
                    keyboard.up = true;
                    event.preventDefault();
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    keyboard.down = true;
                    break;
                case 'Escape':
                    if (isFlyMode && flyControls.isLocked) {
                        flyControls.unlock();
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    keyboard.forward = false;
                    break;
                case 'KeyA':
                    keyboard.left = false;
                    break;
                case 'KeyS':
                    keyboard.backward = false;
                    break;
                case 'KeyD':
                    keyboard.right = false;
                    break;
                case 'Space':
                    keyboard.up = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    keyboard.down = false;
                    break;
            }
        }

        // Toggle between orbit and fly mode
        function toggleControlMode() {
            isFlyMode = !isFlyMode;
            const button = document.getElementById('toggle-controls');

            if (isFlyMode) {
                // Switch to fly mode
                orbitControls.enabled = false;
                scene.add(flyControls.getObject());
                document.getElementById('fly-instructions').style.display = 'block';
                button.textContent = 'Orbit Mode';
                button.style.background = '#FF9800';

                // Stop auto-rotation in fly mode
                stopAutoRotate();

                // Show instructions, wait for click to lock
                document.addEventListener('click', requestPointerLock);
            } else {
                // Switch to orbit mode
                flyControls.unlock();
                scene.remove(flyControls.getObject());
                orbitControls.enabled = true;
                document.getElementById('fly-instructions').style.display = 'none';
                button.textContent = 'Fly Mode (WASD)';
                button.style.background = '#4CAF50';

                // Restart idle timer for auto-rotation
                resetIdleTimer();

                document.removeEventListener('click', requestPointerLock);
            }
        }

        function requestPointerLock(event) {
            // Don't lock pointer when clicking UI elements
            if (event && event.target.closest('#menu-panel, #menu-toggle, #aircraft-popup, #fly-instructions')) {
                return;
            }
            if (isFlyMode && !flyControls.isLocked) {
                flyControls.lock();
            }
        }

        // Clear all trails
        function clearTrails() {
            aircraftData.forEach((data) => {
                // Clear position history
                data.positions = [];
                // Hide trail visuals
                if (data.trail) {
                    data.trail.visible = false;
                }
            });
        }

        // Completely clear all aircraft and visuals from scene
        function clearAllAircraft() {
            // Remove all visual objects and clean up
            aircraftData.forEach((data, hex) => {
                if (data.trail) {
                    trailGroup.remove(data.trail);
                    if (data.trail.geometry) data.trail.geometry.dispose();
                    if (data.trail.material) data.trail.material.dispose();
                }
                if (data.marker) {
                    aircraftGroup.remove(data.marker);
                    if (data.marker.geometry) data.marker.geometry.dispose();
                    if (data.marker.material) data.marker.material.dispose();
                }
                if (data.glow) {
                    aircraftGroup.remove(data.glow);
                    if (data.glow.geometry) data.glow.geometry.dispose();
                    if (data.glow.material) data.glow.material.dispose();
                }
                if (data.label) {
                    data.label.remove();
                    if (activeLabel === data.label) {
                        activeLabel = null;
                    }
                    if (expandedLabel === data.label) {
                        expandedLabel = null;
                    }
                }
            });

            // Clear the aircraft data map
            aircraftData.clear();

            // Clear clickable objects array
            clickableObjects.length = 0;

            console.log('All aircraft and trails cleared');
        }

        // Recording Functions
        function startRecording() {
            if (isRecording || isPlayingBack) return;

            isRecording = true;
            recordingStartTime = Date.now();
            recordingData = {
                version: 1,
                startTime: recordingStartTime,
                centerLat: config.centerLat,
                centerLon: config.centerLon,
                elevation: config.elevation,
                frames: []
            };

            // Update UI
            document.getElementById('menu-record-btn').textContent = 'Stop Recording';
            document.getElementById('menu-record-btn').style.background = '#f44336';
            document.getElementById('recording-status').textContent = 'Active';
            document.getElementById('recording-status').style.color = '#f44336';

            // Track recording start
            trackGAEvent('recording_started', {});

            console.log('Recording started');
        }

        function stopRecording() {
            if (!isRecording) return;

            isRecording = false;

            const durationSec = Math.round((Date.now() - recordingStartTime) / 1000);

            // Update UI
            document.getElementById('menu-record-btn').textContent = 'Start Recording';
            document.getElementById('menu-record-btn').style.background = '#4CAF50';
            document.getElementById('recording-status').textContent = 'Inactive';
            document.getElementById('recording-status').style.color = '#4CAF50';
            document.getElementById('play-recording-btn').style.display = 'block';
            document.getElementById('save-recording-btn').style.display = 'block';
            document.getElementById('clear-recording-btn').style.display = 'block';

            // Track recording stop
            trackGAEvent('recording_stopped', {
                'duration_sec': durationSec,
                'frames': recordingData.frames.length
            });

            console.log(`Recording stopped. Captured ${recordingData.frames.length} frames`);
        }

        function captureFrame() {
            if (!isRecording) return;

            const currentTime = Date.now() - recordingStartTime;

            // Check max duration
            if (currentTime > maxRecordingDuration) {
                stopRecording();
                alert('Maximum recording duration reached (6 hours)');
                return;
            }

            const frame = {
                time: currentTime,
                aircraft: []
            };

            // Capture aircraft data (compressed format)
            aircraftData.forEach((data, hex) => {
                if (data.positions.length === 0) return;

                const lastPos = data.positions[data.positions.length - 1];

                // Store only essential data
                frame.aircraft.push({
                    hex: hex,
                    lat: data.rawData?.lat,
                    lon: data.rawData?.lon,
                    alt: data.rawData?.alt_baro !== 'ground' ? data.rawData.alt_baro : 0,
                    callsign: data.info?.callsign || hex,
                    type: data.info?.type || '',
                    speed: data.info?.speed || 0,
                    track: data.info?.track || 0,
                    registration: data.info?.registration || ''
                });
            });

            recordingData.frames.push(frame);

            // Update UI
            updateRecordingUI();
        }

        function updateRecordingUI() {
            if (!recordingData) return;

            const duration = isRecording
                ? Date.now() - recordingStartTime
                : recordingData.frames.length > 0
                    ? recordingData.frames[recordingData.frames.length - 1].time
                    : 0;

            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            document.getElementById('recording-duration').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Estimate memory usage
            const estimatedBytes = JSON.stringify(recordingData).length;
            const estimatedMB = (estimatedBytes / (1024 * 1024)).toFixed(2);
            document.getElementById('recording-memory').textContent = `${estimatedMB} MB`;

            const memoryIndicator = document.getElementById('memory-indicator');
            const memoryNum = parseFloat(estimatedMB);

            // Memory thresholds for 6-hour recording
            if (memoryNum >= 1000) {
                // Critical: Stop recording to prevent browser crash
                if (isRecording) {
                    stopRecording();
                    alert('Recording stopped: Memory limit reached (1 GB). Save your recording to prevent data loss.');
                }
                memoryIndicator.textContent = `🛑 CRITICAL: ${estimatedMB} MB - Recording stopped`;
                memoryIndicator.className = 'memory-indicator critical';
            } else if (memoryNum >= 750) {
                // Warning: Approaching limit
                memoryIndicator.textContent = `⚠️ WARNING: ${estimatedMB} MB / 1000 MB limit`;
                memoryIndicator.className = 'memory-indicator critical';
            } else if (memoryNum >= 500) {
                // Caution
                memoryIndicator.textContent = `⚠️ ${estimatedMB} MB / 1000 MB limit`;
                memoryIndicator.className = 'memory-indicator warning';
            } else {
                memoryIndicator.textContent = `Memory: ${estimatedMB} MB`;
                memoryIndicator.className = 'memory-indicator';
            }
        }

        function clearRecording() {
            if (isRecording) {
                stopRecording();
            }

            recordingData = null;
            document.getElementById('play-recording-btn').style.display = 'none';
            document.getElementById('save-recording-btn').style.display = 'none';
            document.getElementById('clear-recording-btn').style.display = 'none';
            document.getElementById('recording-duration').textContent = '0:00';
            document.getElementById('recording-memory').textContent = '0 MB';
            document.getElementById('memory-indicator').textContent = '';

            console.log('Recording cleared');
        }

        // Playback Functions
        function startPlayback(data) {
            if (isRecording) return;
            if (!data || !data.frames || data.frames.length === 0) {
                alert('No recording data to play');
                return;
            }

            // If already playing, stop the current playback first
            if (isPlayingBack) {
                if (playbackIntervalId) {
                    clearInterval(playbackIntervalId);
                    playbackIntervalId = null;
                }
            }

            playbackData = data;
            isPlayingBack = true;
            playbackPaused = false;
            playbackCurrentTime = 0;
            playbackStartTime = Date.now(); // Starting from 0, so this is correct

            // Stop live updates
            if (updateIntervalId) {
                clearInterval(updateIntervalId);
                updateIntervalId = null;
            }

            // Completely clear all existing aircraft and trails
            clearAllAircraft();

            // Set location from recording
            config.centerLat = playbackData.centerLat;
            config.centerLon = playbackData.centerLon;
            config.elevation = playbackData.elevation || 0;

            // Update UI
            document.getElementById('play-pause-btn').style.display = 'block';
            document.getElementById('play-pause-btn').textContent = '⏸ Pause';
            document.getElementById('stop-playback-btn').style.display = 'block';
            document.getElementById('timeline-container').style.display = 'block';
            document.getElementById('speed-controls').style.display = 'block';

            const totalDuration = playbackData.frames[playbackData.frames.length - 1].time;
            document.getElementById('timeline-slider').max = totalDuration;
            updatePlaybackTimeDisplay();

            // Start playback loop
            playbackIntervalId = setInterval(updatePlayback, 50); // 20 FPS

            console.log('Playback started');
        }

        function stopPlayback() {
            if (!isPlayingBack) return;

            isPlayingBack = false;
            playbackPaused = false;

            if (playbackIntervalId) {
                clearInterval(playbackIntervalId);
                playbackIntervalId = null;
            }

            // Completely clear all playback data and visuals
            clearAllAircraft();

            // Hide playback UI
            document.getElementById('play-pause-btn').style.display = 'none';
            document.getElementById('stop-playback-btn').style.display = 'none';
            document.getElementById('timeline-container').style.display = 'none';
            document.getElementById('speed-controls').style.display = 'none';

            // Restart live updates
            updateIntervalId = setInterval(fetchAircraftData, config.updateInterval);

            console.log('Playback stopped');
        }

        function togglePlayPause() {
            if (!isPlayingBack) return;

            playbackPaused = !playbackPaused;
            const btn = document.getElementById('play-pause-btn');

            if (playbackPaused) {
                btn.textContent = '▶ Play';
            } else {
                btn.textContent = '⏸ Pause';
                // Adjust for playback speed when resuming
                playbackStartTime = Date.now() - (playbackCurrentTime / playbackSpeed);
            }
        }

        function updatePlayback() {
            if (!isPlayingBack || playbackPaused) return;

            // Calculate current time based on speed
            const elapsed = (Date.now() - playbackStartTime) * playbackSpeed;
            playbackCurrentTime = elapsed;

            const totalDuration = playbackData.frames[playbackData.frames.length - 1].time;

            // Check if playback finished
            if (playbackCurrentTime >= totalDuration) {
                playbackCurrentTime = totalDuration;
                playbackPaused = true;
                document.getElementById('play-pause-btn').textContent = '▶ Play';
            }

            // Find frames to interpolate between
            let prevFrame = null;
            let nextFrame = null;

            for (let i = 0; i < playbackData.frames.length; i++) {
                if (playbackData.frames[i].time <= playbackCurrentTime) {
                    prevFrame = playbackData.frames[i];
                }
                if (playbackData.frames[i].time >= playbackCurrentTime && !nextFrame) {
                    nextFrame = playbackData.frames[i];
                    break;
                }
            }

            if (!prevFrame) prevFrame = playbackData.frames[0];
            if (!nextFrame) nextFrame = playbackData.frames[playbackData.frames.length - 1];

            // Interpolate and update aircraft
            updatePlaybackFrame(prevFrame, nextFrame, playbackCurrentTime);
            updatePlaybackTimeDisplay();
        }

        function updatePlaybackFrame(prevFrame, nextFrame, currentTime) {
            const t = prevFrame === nextFrame ? 0 :
                (currentTime - prevFrame.time) / (nextFrame.time - prevFrame.time);

            // Track active aircraft in this frame
            const activeHexes = new Set();

            // Process all aircraft from both frames
            const allHexes = new Set([
                ...prevFrame.aircraft.map(a => a.hex),
                ...nextFrame.aircraft.map(a => a.hex)
            ]);

            allHexes.forEach(hex => {
                const prevAc = prevFrame.aircraft.find(a => a.hex === hex);
                const nextAc = nextFrame.aircraft.find(a => a.hex === hex);

                if (!prevAc && !nextAc) return;

                const ac = prevAc || nextAc;
                let lat, lon, alt;

                // Interpolate position if both frames have this aircraft
                if (prevAc && nextAc) {
                    lat = prevAc.lat + (nextAc.lat - prevAc.lat) * t;
                    lon = prevAc.lon + (nextAc.lon - prevAc.lon) * t;
                    alt = prevAc.alt + (nextAc.alt - prevAc.alt) * t;
                } else {
                    lat = ac.lat;
                    lon = ac.lon;
                    alt = ac.alt;
                }

                activeHexes.add(hex);

                const position = latLonToCartesian(lat, lon, alt);

                if (!aircraftData.has(hex)) {
                    aircraftData.set(hex, {
                        positions: [],
                        lastUpdate: Date.now(),
                        info: {},
                        rawData: { lat, lon, alt_baro: alt },
                        trail: null,
                        marker: null,
                        glow: null,
                        label: null
                    });
                }

                const data = aircraftData.get(hex);
                data.positions.push({
                    position,
                    timestamp: Date.now(),
                    altitude: alt
                });

                // Keep only recent positions
                data.positions = data.positions.slice(-config.maxTrailLength);
                data.lastUpdate = Date.now();
                data.rawData = { lat, lon, alt_baro: alt };
                data.info = {
                    callsign: ac.callsign || hex,
                    registration: ac.registration || '',
                    type: ac.type || '',
                    altitude: alt,
                    speed: ac.speed || 0,
                    track: ac.track || 0
                };
            });

            // Remove aircraft not in current frame
            for (const [hex, data] of aircraftData.entries()) {
                if (!activeHexes.has(hex)) {
                    // If this is the followed aircraft, clear the follow
                    if (hex === followedAircraftHex) {
                        followedAircraftHex = null;
                        updateFollowedAircraftUI();

                        // Re-render airspace if focus mode is enabled (to update back to original center)
                        if (airspaceEnabled && airspaceFocusOnly) {
                            renderAirspace();
                        }
                    }

                    if (data.trail) {
                        trailGroup.remove(data.trail);
                        if (data.trail.geometry) data.trail.geometry.dispose();
                        if (data.trail.material) data.trail.material.dispose();
                    }
                    if (data.marker) {
                        aircraftGroup.remove(data.marker);
                        if (data.marker.geometry) data.marker.geometry.dispose();
                        if (data.marker.material) data.marker.material.dispose();
                    }
                    if (data.glow) {
                        aircraftGroup.remove(data.glow);
                        if (data.glow.geometry) data.glow.geometry.dispose();
                        if (data.glow.material) data.glow.material.dispose();
                    }
                    if (data.label) {
                        data.label.remove();
                        if (activeLabel === data.label) {
                            activeLabel = null;
                        }
                        if (expandedLabel === data.label) {
                            expandedLabel = null;
                        }
                    }
                    aircraftData.delete(hex);
                }
            }

            updateVisuals();
        }

        function updatePlaybackTimeDisplay() {
            const current = Math.floor(playbackCurrentTime / 1000);
            const total = Math.floor(playbackData.frames[playbackData.frames.length - 1].time / 1000);

            const currentMin = Math.floor(current / 60);
            const currentSec = current % 60;
            const totalMin = Math.floor(total / 60);
            const totalSec = total % 60;

            document.getElementById('current-time').textContent =
                `${currentMin}:${currentSec.toString().padStart(2, '0')}`;
            document.getElementById('total-time').textContent =
                `${totalMin}:${totalSec.toString().padStart(2, '0')}`;
            document.getElementById('timeline-slider').value = playbackCurrentTime;
        }

        function seekPlayback(time) {
            if (!isPlayingBack) return;

            playbackCurrentTime = time;
            // Adjust for playback speed when calculating start time
            playbackStartTime = Date.now() - (playbackCurrentTime / playbackSpeed);

            // Clear all aircraft and rebuild trails up to this point
            rebuildTrailsToTime(time);

            updatePlaybackTimeDisplay();
        }

        function rebuildTrailsToTime(targetTime) {
            // Clear all existing aircraft and trails
            clearAllAircraft();

            // Replay all frames from start to target time to rebuild trails
            const framesToProcess = playbackData.frames.filter(frame => frame.time <= targetTime);

            framesToProcess.forEach((frame) => {
                frame.aircraft.forEach(ac => {
                    const hex = ac.hex;
                    const position = latLonToCartesian(ac.lat, ac.lon, ac.alt);

                    if (!aircraftData.has(hex)) {
                        aircraftData.set(hex, {
                            positions: [],
                            lastUpdate: Date.now(),
                            info: {},
                            rawData: { lat: ac.lat, lon: ac.lon, alt_baro: ac.alt },
                            trail: null,
                            marker: null,
                            glow: null,
                            label: null
                        });
                    }

                    const data = aircraftData.get(hex);
                    data.positions.push({
                        position,
                        timestamp: Date.now(),
                        altitude: ac.alt
                    });

                    // Keep only recent positions
                    data.positions = data.positions.slice(-config.maxTrailLength);
                    data.lastUpdate = Date.now();
                    data.rawData = { lat: ac.lat, lon: ac.lon, alt_baro: ac.alt };
                    data.info = {
                        callsign: ac.callsign || hex,
                        registration: ac.registration || '',
                        type: ac.type || '',
                        altitude: ac.alt,
                        speed: ac.speed || 0,
                        track: ac.track || 0
                    };
                });
            });

            // Update visuals to show the rebuilt trails
            updateVisuals();
        }

        function setPlaybackSpeed(speed) {
            playbackSpeed = speed;
            // Recalculate start time with new speed to maintain current position
            playbackStartTime = Date.now() - (playbackCurrentTime / playbackSpeed);

            // Update UI
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.speed-btn[data-speed="${speed}"]`)?.classList.add('active');
        }

        // Save/Load Functions
        function saveRecording() {
            if (!recordingData || recordingData.frames.length === 0) {
                alert('No recording to save');
                return;
            }

            // Create filename with timestamp
            const date = new Date(recordingData.startTime);
            const dateStr = date.toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `airloom-recording-${dateStr}.json`;

            // Convert to JSON and create blob
            const json = JSON.stringify(recordingData);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            // Create download link
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();

            // Clean up
            URL.revokeObjectURL(url);

            console.log(`Recording saved as ${filename}`);
        }

        function loadRecording() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);

                        // Validate recording data
                        if (!data.version || !data.frames || !Array.isArray(data.frames)) {
                            alert('Invalid recording file format');
                            return;
                        }

                        // Stop any current recording or playback
                        if (isRecording) {
                            stopRecording();
                        }
                        if (isPlayingBack) {
                            stopPlayback();
                        }

                        // Start playback with loaded data
                        startPlayback(data);
                        console.log(`Loaded recording with ${data.frames.length} frames`);
                    } catch (error) {
                        alert('Error loading recording file: ' + error.message);
                        console.error(error);
                    }
                };

                reader.readAsText(file);
            };

            input.click();
        }

        // Auto-rotate functions
        function resetIdleTimer() {
            // Stop auto-rotation
            if (orbitControls && !isFlyMode) {
                orbitControls.autoRotate = false;
            }

            // Clear existing timer
            if (idleTimer) {
                clearTimeout(idleTimer);
            }

            // Start new timer if auto-rotate is enabled
            if (autoRotateEnabled && !isFlyMode) {
                idleTimer = setTimeout(() => {
                    if (orbitControls && !isFlyMode) {
                        orbitControls.autoRotate = true;
                        console.log('Auto-rotate enabled after idle');
                    }
                }, idleTimeout);
            }
        }

        function stopAutoRotate() {
            if (orbitControls) {
                orbitControls.autoRotate = false;
            }
            if (idleTimer) {
                clearTimeout(idleTimer);
                idleTimer = null;
            }
        }

        // Initialize controls
        function initControls() {
            // Menu toggle
            document.getElementById('menu-toggle').addEventListener('click', (e) => {
                e.stopPropagation();
                const panel = document.getElementById('menu-panel');
                panel.classList.toggle('open');
            });

            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                const panel = document.getElementById('menu-panel');
                const toggle = document.getElementById('menu-toggle');
                if (!panel.contains(e.target) && !toggle.contains(e.target)) {
                    panel.classList.remove('open');
                }
            });

            // Airport search input
            const airportSearchInput = document.getElementById('airport-search-input');
            let searchTimeout;

            airportSearchInput.addEventListener('input', async (e) => {
                const query = e.target.value.trim();

                // Clear previous timeout
                clearTimeout(searchTimeout);

                if (query.length < 2) {
                    hideAirportSuggestions();
                    return;
                }

                // Debounce search
                searchTimeout = setTimeout(async () => {
                    try {
                        // Show loading state
                        const container = document.getElementById('airport-suggestions');
                        container.innerHTML = '<div class="airport-loading">Loading airports...</div>';
                        container.style.display = 'block';

                        // Load airports data if not already loaded
                        await loadAirportsData();

                        // Filter and show suggestions
                        const suggestions = filterAirports(query);
                        showAirportSuggestions(suggestions);
                    } catch (error) {
                        console.error('Airport search error:', error);
                        const container = document.getElementById('airport-suggestions');
                        container.innerHTML = '<div class="airport-no-results">Error loading airports</div>';
                        container.style.display = 'block';
                    }
                }, 300); // 300ms debounce
            });

            // Hide suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#airport-search-input') && !e.target.closest('#airport-suggestions')) {
                    hideAirportSuggestions();
                }
            });

            // Clear input when focused (optional - for better UX)
            airportSearchInput.addEventListener('focus', () => {
                if (airportSearchInput.value && airportSearchInput.value.includes(' - ')) {
                    // If it's a selected airport, clear it to allow new search
                    airportSearchInput.value = '';
                }
            });

            // Use My Location button
            document.getElementById('use-my-location').addEventListener('click', () => {
                getUserLocation();
            });

            // Flight search controls
            document.getElementById('flight-search-btn').addEventListener('click', () => {
                const callsign = document.getElementById('flight-search-input').value.trim();
                if (callsign) {
                    searchByCallsign(callsign);
                }
            });

            document.getElementById('flight-search-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const callsign = e.target.value.trim();
                    if (callsign) {
                        searchByCallsign(callsign);
                    }
                }
            });

            // Camera controls
            document.getElementById('reset-camera').addEventListener('click', () => {
                // Track camera reset
                trackGAEvent('camera_reset', {});

                camera.position.set(0, 50, 100);
                if (!isFlyMode) {
                    controls.target.set(0, 0, 0);
                    controls.update();
                }
            });

            document.getElementById('clear-trails').addEventListener('click', () => {
                // Track trails cleared
                trackGAEvent('trails_cleared', {
                    'aircraft_count': aircraftData.size
                });

                clearTrails();
            });

            document.getElementById('toggle-controls').addEventListener('click', (e) => {
                e.stopPropagation();

                // Track control mode toggle (track before toggle so we know the new mode)
                trackGAEvent('control_mode_toggled', {
                    'new_mode': isFlyMode ? 'orbit' : 'fly'
                });

                toggleControlMode();
            });

            // Visual settings
            document.getElementById('trail-length').addEventListener('input', (e) => {
                config.maxTrailLength = parseInt(e.target.value);
                document.getElementById('trail-length-value').textContent = e.target.value;
            });

            document.getElementById('altitude-scale').addEventListener('input', (e) => {
                config.altitudeScale = parseFloat(e.target.value);
                document.getElementById('altitude-scale-value').textContent = e.target.value;
                updateAllPositions();
            });

            document.getElementById('floor-height').addEventListener('input', (e) => {
                config.floorHeight = parseFloat(e.target.value);
                document.getElementById('floor-height-value').textContent = e.target.value;
                // Re-fetch data to recalculate all positions with new ground elevation
                fetchAircraftData();
            });

            // Data settings
            document.getElementById('update-rate').addEventListener('input', (e) => {
                const newRate = parseInt(e.target.value) * 1000;
                config.updateInterval = newRate;
                document.getElementById('update-rate-value').textContent = e.target.value;

                // Restart interval with new rate
                if (updateIntervalId) {
                    clearInterval(updateIntervalId);
                }
                updateIntervalId = setInterval(fetchAircraftData, config.updateInterval);
            });

            // Logarithmic scale conversion functions
            function sliderToRadius(sliderValue) {
                // Logarithmic scale: 0-100 slider maps to 10-16000 km
                // Formula: radius = 10 * (16000/10)^(sliderValue/100)
                const minRadius = 10;
                const maxRadius = 16000;
                const ratio = Math.pow(maxRadius / minRadius, sliderValue / 100);
                return Math.round(minRadius * ratio);
            }

            function radiusToSlider(radius) {
                // Inverse of sliderToRadius
                const minRadius = 10;
                const maxRadius = 16000;
                const sliderValue = 100 * Math.log(radius / minRadius) / Math.log(maxRadius / minRadius);
                return Math.max(0, Math.min(100, Math.round(sliderValue)));
            }

            function updateRadius(newRadius) {
                // Clamp radius to valid range
                newRadius = Math.max(10, Math.min(16000, newRadius));

                config.radius = newRadius;
                document.getElementById('search-radius-value').textContent = newRadius;
                document.getElementById('search-radius').value = radiusToSlider(newRadius);

                // Auto-adjust settings for large search radius (>500km)
                if (config.radius > 500) {
                    // Enable borders for geographic reference
                    if (!showBoundaries) {
                        document.getElementById('show-boundaries').checked = true;
                        showBoundaries = true;
                        boundariesGroup.visible = true;
                        console.log('🗺️ Borders auto-enabled for large search radius');
                    }

                    // Set fog to max distance for better visibility
                    document.getElementById('fog-distance').value = 20000;
                    document.getElementById('fog-distance-value').textContent = '20000';
                    if (scene.fog) {
                        scene.fog.near = 4000;
                        scene.fog.far = 20000;
                    }

                    // Disable map tiles to prevent memory issues
                    if (currentMapLayer !== 'none') {
                        document.getElementById('map-layer-select').value = 'none';
                        document.getElementById('map-layer-select').dispatchEvent(new Event('change'));
                        console.log('🗺️ Map tiles auto-disabled for large search radius (memory optimization)');
                    }
                }

                // Update airspace data for new radius
                if (airspaceEnabled) {
                    fetchAirspaceData();
                    // Also re-render immediately if focus mode is enabled to filter existing airspace
                    if (airspaceFocusOnly) {
                        renderAirspace();
                    }
                }

                // If in focused mode, update shader uniforms for all loaded tiles
                if (focusedTilesMode) {
                    // Update map tile shaders
                    for (const [tileKey, tile] of loadedTiles.entries()) {
                        if (tile.material && tile.material.uniforms && tile.material.uniforms.searchRadius) {
                            tile.material.uniforms.searchRadius.value = config.radius;
                        }
                    }
                    // Update terrain tile shaders
                    for (const [tileKey, tile] of loadedTerrainTiles.entries()) {
                        if (tile.material && tile.material.uniforms && tile.material.uniforms.searchRadius) {
                            tile.material.uniforms.searchRadius.value = config.radius;
                        }
                    }
                }

                // Reload map tiles with new radius
                if (currentMapLayer !== 'none') {
                    updateVisibleTiles(config.centerLat, config.centerLon, config.radius, currentMapLayer);
                }
                // Also reload terrain tiles if enabled and in focused mode
                if (terrainEnabled && focusedTilesMode) {
                    updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);
                }
            }

            // Slider with logarithmic scale
            document.getElementById('search-radius').addEventListener('input', (e) => {
                const radius = sliderToRadius(parseInt(e.target.value));
                updateRadius(radius);
            });

            // Fine-tune controls
            document.getElementById('radius-decrease').addEventListener('click', () => {
                let step = config.radius <= 100 ? 5 : config.radius <= 500 ? 25 : config.radius <= 1000 ? 50 : 100;
                updateRadius(config.radius - step);
            });

            document.getElementById('radius-increase').addEventListener('click', () => {
                let step = config.radius < 100 ? 5 : config.radius < 500 ? 25 : config.radius < 1000 ? 50 : 100;
                updateRadius(config.radius + step);
            });

            // Initialize radius on page load
            updateRadius(100);

            // Filters
            document.getElementById('filter-callsign').addEventListener('input', (e) => {
                filters.callsign = e.target.value;

                // Track filter usage (only when non-empty)
                if (e.target.value.trim()) {
                    trackGAEvent('filter_callsign_used', {
                        'has_value': true
                    });
                }

                applyFilters();
            });

            document.getElementById('filter-type').addEventListener('input', (e) => {
                filters.type = e.target.value;

                // Track filter usage (only when non-empty)
                if (e.target.value.trim()) {
                    trackGAEvent('filter_type_used', {
                        'has_value': true
                    });
                }

                applyFilters();

                // Easter egg: hide/show branding label
                if (e.target.value.toLowerCase() === 'asdf') {
                    if (brandingLabel) {
                        brandingLabel.visible = false;
                        console.log('Branding hidden');
                    }
                } else if (e.target.value.toLowerCase() === 'qwer') {
                    if (brandingLabel) {
                        brandingLabel.visible = true;
                        console.log('Branding shown');
                    }
                }
            });

            document.getElementById('filter-altitude-min').addEventListener('input', (e) => {
                filters.altitudeMin = e.target.value ? parseFloat(e.target.value) : null;

                // Track filter usage (only when value set)
                if (e.target.value) {
                    trackGAEvent('filter_altitude_min_used', {
                        'value': parseFloat(e.target.value)
                    });
                }

                applyFilters();
            });

            document.getElementById('filter-altitude-max').addEventListener('input', (e) => {
                filters.altitudeMax = e.target.value ? parseFloat(e.target.value) : null;

                // Track filter usage (only when value set)
                if (e.target.value) {
                    trackGAEvent('filter_altitude_max_used', {
                        'value': parseFloat(e.target.value)
                    });
                }

                applyFilters();
            });

            document.getElementById('filter-ground').addEventListener('change', (e) => {
                filters.showGround = e.target.checked;

                // Track ground filter toggle
                trackGAEvent('filter_ground_toggled', {
                    'show_ground': e.target.checked
                });

                applyFilters();
            });

            document.getElementById('filter-remove-mode').addEventListener('change', (e) => {
                filters.removeMode = e.target.checked;

                // Track remove mode toggle
                trackGAEvent('filter_remove_mode_toggled', {
                    'remove_mode': e.target.checked
                });

                // Apply filters immediately to remove or show aircraft
                applyFilters();
            });

            document.getElementById('reset-filters').addEventListener('click', () => {
                // Track filter reset
                trackGAEvent('filters_reset', {});

                filters.callsign = '';
                filters.type = '';
                filters.altitudeMin = null;
                filters.altitudeMax = 100000;
                filters.showGround = true;

                document.getElementById('filter-callsign').value = '';
                document.getElementById('filter-type').value = '';
                document.getElementById('filter-altitude-min').value = '';
                document.getElementById('filter-altitude-max').value = '100000';
                document.getElementById('filter-ground').checked = true;

                applyFilters();
            });

            // ====================================================================
            // Boundaries control
            document.getElementById('show-boundaries').addEventListener('change', (e) => {
                showBoundaries = e.target.checked;
                boundariesGroup.visible = showBoundaries;

                // Track boundaries toggle
                trackGAEvent('boundaries_toggled', {
                    'enabled': showBoundaries
                });

                console.log(`🗺️ Boundaries ${showBoundaries ? 'shown' : 'hidden'}`);
            });

            // ====================================================================
            // Airspace controls
            document.getElementById('show-airspace').addEventListener('change', (e) => {
                airspaceEnabled = e.target.checked;

                // Track airspace toggle
                trackGAEvent('airspace_toggled', {
                    'enabled': airspaceEnabled
                });

                if (airspaceEnabled) {
                    fetchAirspaceData();
                } else {
                    renderAirspace(); // Clear airspace
                }
            });

            document.getElementById('show-class-b').addEventListener('change', (e) => {
                showClassB = e.target.checked;

                // Track Class B toggle
                trackGAEvent('airspace_class_b_toggled', {
                    'visible': showClassB
                });

                renderAirspace();
            });

            document.getElementById('show-class-c').addEventListener('change', (e) => {
                showClassC = e.target.checked;

                // Track Class C toggle
                trackGAEvent('airspace_class_c_toggled', {
                    'visible': showClassC
                });

                renderAirspace();
            });

            document.getElementById('show-class-d').addEventListener('change', (e) => {
                showClassD = e.target.checked;

                // Track Class D toggle
                trackGAEvent('airspace_class_d_toggled', {
                    'visible': showClassD
                });

                renderAirspace();
            });

            document.getElementById('airspace-focus-only').addEventListener('change', (e) => {
                airspaceFocusOnly = e.target.checked;

                // Track airspace focus toggle
                trackGAEvent('airspace_focus_toggled', {
                    'enabled': airspaceFocusOnly
                });

                console.log(`🎯 Airspace Focus Mode ${airspaceFocusOnly ? 'ENABLED' : 'DISABLED'} - Only showing airspace within ${config.radius}km radius`);
                renderAirspace();
            });

            document.getElementById('airspace-wireframe-only').addEventListener('change', (e) => {
                airspaceWireframeOnly = e.target.checked;

                // Track airspace wireframe toggle
                trackGAEvent('airspace_wireframe_toggled', {
                    'enabled': airspaceWireframeOnly
                });

                console.log(`🔲 Airspace Wireframe Mode ${airspaceWireframeOnly ? 'ENABLED' : 'DISABLED'}`);
                renderAirspace();
            });

            document.getElementById('airspace-opacity').addEventListener('input', (e) => {
                const opacity = parseFloat(e.target.value);
                document.getElementById('airspace-opacity-value').textContent = opacity.toFixed(1);
                updateAirspaceOpacity(opacity);
            });

            // Follow aircraft toggle
            document.getElementById('follow-aircraft').addEventListener('change', (e) => {
                followModeEnabled = e.target.checked;

                // Track follow mode toggle
                trackGAEvent('follow_mode_toggled', {
                    'enabled': followModeEnabled
                });

                if (!followModeEnabled) {
                    // Reset camera target to center
                    if (orbitControls) {
                        orbitControls.target.set(0, 0, 0);
                        orbitControls.update();
                    }
                    // Clear follow search tracking
                    followSearchLat = null;
                    followSearchLon = null;
                    lastFollowSearchLat = null;
                    lastFollowSearchLon = null;
                    // Clear progressive map tracking
                    lastMapCenterLat = null;
                    lastMapCenterLon = null;
                    // Clear URL parameter when flight following is disabled
                    updateURLParam(null);
                }
            });

            // Surf mode toggle
            document.getElementById('surf-mode').addEventListener('change', (e) => {
                surfModeEnabled = e.target.checked;

                // Track surf mode toggle
                trackGAEvent('surf_mode_toggled', {
                    'enabled': surfModeEnabled
                });

                console.log(`🏄 Surf Mode ${surfModeEnabled ? 'enabled' : 'disabled'} - Will auto-switch aircraft when current is lost`);
            });

            // Share flight button in menu
            document.getElementById('menu-share-flight-btn').addEventListener('click', function() {
                shareCurrentFlight(this);
            });

            // Handle clicks on aircraft and elsewhere
            window.addEventListener('click', (e) => {
                if (!isFlyMode || !flyControls.isLocked) {
                    onAircraftClick(e);
                }
            });

            // Keyboard handlers
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Auto-rotate toggle
            document.getElementById('auto-rotate').addEventListener('change', (e) => {
                autoRotateEnabled = e.target.checked;

                // Track auto-rotate toggle
                trackGAEvent('auto_rotate_toggled', {
                    'enabled': autoRotateEnabled
                });

                if (autoRotateEnabled) {
                    resetIdleTimer();
                } else {
                    stopAutoRotate();
                }
            });

            // Compass toggle
            document.getElementById('show-compass').addEventListener('change', (e) => {
                compassEnabled = e.target.checked;

                // Track compass toggle
                trackGAEvent('compass_toggled', {
                    'visible': compassEnabled
                });

                document.getElementById('compass').style.display = compassEnabled ? 'block' : 'none';
            });

            // Compass click to reset north
            document.getElementById('compass').addEventListener('click', () => {
                if (!compassEnabled) return;

                // Track compass north reset
                trackGAEvent('compass_north_reset', {});

                // Calculate horizontal distance in XZ plane (preserves zoom level)
                const dx = camera.position.x - orbitControls.target.x;
                const dz = camera.position.z - orbitControls.target.z;
                const horizontalDistance = Math.sqrt(dx * dx + dz * dz);

                // Calculate elevation (vertical offset)
                const elevation = camera.position.y - orbitControls.target.y;

                const targetX = orbitControls.target.x;
                const targetZ = orbitControls.target.z;

                // Set camera to look from south (positive Z) toward north (negative Z)
                // This makes north "up" on screen
                camera.position.set(targetX, orbitControls.target.y + elevation, targetZ + horizontalDistance);
                orbitControls.update();

                console.log('🧭 Camera reset to north orientation');
            });

            // Color mode toggle
            document.getElementById('color-by-speed').addEventListener('change', (e) => {
                colorMode = e.target.checked ? 'speed' : 'altitude';

                // Track color mode change
                trackGAEvent('color_mode_changed', {
                    'mode': colorMode
                });

                // Update visuals to reflect new color mode
                updateVisuals();
            });

            // Axes helper toggle
            document.getElementById('show-axes').addEventListener('change', (e) => {
                // Track axes toggle
                trackGAEvent('axes_toggled', {
                    'visible': e.target.checked
                });

                if (axesHelper) {
                    axesHelper.visible = e.target.checked;
                }
            });

            // Grid helper toggle
            document.getElementById('show-grid').addEventListener('change', (e) => {
                // Track grid toggle
                trackGAEvent('grid_toggled', {
                    'visible': e.target.checked
                });

                if (gridHelper) {
                    gridHelper.visible = e.target.checked;
                }
            });

            // Map layer selector
            document.getElementById('map-layer-select').addEventListener('change', (e) => {
                const layerValue = e.target.value;

                // Track map layer change
                trackGAEvent('map_layer_changed', {
                    'layer': layerValue,
                    'is_3d': layerValue.includes('terrain') || layerValue === 'satellite' || layerValue === 'wireframe'
                });

                // Handle dark map + terrain layers
                if (layerValue === 'dark-terrain' || layerValue === 'dark-nolabels-terrain') {
                    terrainEnabled = true;
                    terrainTextureMode = 'map';

                    // Set the underlying dark map layer
                    currentMapLayer = layerValue === 'dark-terrain' ? 'dark' : 'dark-nolabels';

                    // Hide flat map tiles
                    tilesGroup.visible = false;

                    // Clear existing terrain
                    for (const tileKey of loadedTerrainTiles.keys()) {
                        unloadTerrainTile(tileKey);
                    }

                    // Load terrain with dark map texture
                    updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);
                    console.log(`🏔️ Terrain ENABLED with dark map (${currentMapLayer}) texture`);
                }
                // Handle terrain-based layers (satellite, wireframe)
                else if (layerValue === 'satellite' || layerValue === 'wireframe') {
                    terrainEnabled = true;
                    terrainTextureMode = layerValue;

                    // Hide flat map tiles
                    tilesGroup.visible = false;

                    // Clear existing terrain
                    for (const tileKey of loadedTerrainTiles.keys()) {
                        unloadTerrainTile(tileKey);
                    }

                    // Load terrain with appropriate texture
                    updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);
                    console.log(`🏔️ Terrain ENABLED with ${terrainTextureMode} texture`);
                } else {
                    // Handle flat map layers (none, dark, dark-nolabels)
                    terrainEnabled = false;
                    currentMapLayer = layerValue;

                    // Show flat map tiles
                    tilesGroup.visible = true;

                    // Clear terrain
                    for (const tileKey of loadedTerrainTiles.keys()) {
                        unloadTerrainTile(tileKey);
                    }

                    // Load flat map tiles
                    updateVisibleTiles(config.centerLat, config.centerLon, config.radius, currentMapLayer);
                    console.log(`🗺️ Flat map enabled with ${currentMapLayer} layer`);
                }
            });

            // Map brightness slider
            document.getElementById('map-brightness').addEventListener('input', (e) => {
                mapBrightness = parseFloat(e.target.value);
                const percentage = Math.round(mapBrightness * 100);
                document.getElementById('map-brightness-value').textContent = `${percentage}%`;

                // Update all map tile materials
                for (const [tileKey, tile] of loadedTiles.entries()) {
                    if (tile.material && tile.material.uniforms && tile.material.uniforms.brightness) {
                        tile.material.uniforms.brightness.value = mapBrightness;
                    }
                }

                // Update all terrain tile materials (when using map texture)
                for (const [tileKey, tile] of loadedTerrainTiles.entries()) {
                    if (tile.material && tile.material.uniforms && tile.material.uniforms.brightness) {
                        tile.material.uniforms.brightness.value = mapBrightness;
                    }
                }
            });

            // Terrain segment density selector (for wireframe detail)
            document.getElementById('terrain-density-select').addEventListener('change', (e) => {
                terrainSegmentDensity = parseInt(e.target.value);
                console.log(`🔲 Terrain density changed to: ${terrainSegmentDensity}x${terrainSegmentDensity}`);

                // Track terrain density change
                trackGAEvent('terrain_density_changed', {
                    'density': terrainSegmentDensity
                });

                // Reload all terrain tiles with new density
                if (terrainEnabled) {
                    // Clear existing terrain
                    for (const tileKey of loadedTerrainTiles.keys()) {
                        unloadTerrainTile(tileKey);
                    }
                    // Reload with new density
                    updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);
                }
            });

            // Terrain color hue slider
            document.getElementById('terrain-hue').addEventListener('input', (e) => {
                const hue = parseInt(e.target.value);
                config.terrainColorHue = hue;
                const hueLabel = hue === 0 ? '0° (gray)' : `${hue}°`;
                document.getElementById('terrain-hue-value').textContent = hueLabel;

                // Update all terrain materials
                if (terrainEnabled) {
                    loadedTerrainTiles.forEach(tile => {
                        if (tile.material && tile.material.uniforms && tile.material.uniforms.wireframeColor) {
                            tile.material.uniforms.wireframeColor.value = getTerrainColor();
                        } else if (tile.material && tile.material.color) {
                            tile.material.color = getTerrainColor();
                        }
                    });
                }
            });

            // Terrain brightness slider
            document.getElementById('terrain-brightness').addEventListener('input', (e) => {
                const brightness = parseInt(e.target.value);
                config.terrainBrightness = brightness;
                document.getElementById('terrain-brightness-value').textContent = `${brightness}%`;

                // Update all terrain materials
                if (terrainEnabled) {
                    loadedTerrainTiles.forEach(tile => {
                        if (tile.material && tile.material.uniforms && tile.material.uniforms.wireframeColor) {
                            tile.material.uniforms.wireframeColor.value = getTerrainColor();
                        } else if (tile.material && tile.material.color) {
                            tile.material.color = getTerrainColor();
                        }
                    });
                }
            });

            // Elevation gradient toggle
            document.getElementById('elevation-gradient').addEventListener('change', (e) => {
                config.elevationGradient = e.target.checked;

                // Track elevation gradient toggle
                trackGAEvent('elevation_gradient_toggled', {
                    'enabled': config.elevationGradient
                });

                console.log(`🌈 Elevation gradient ${config.elevationGradient ? 'ENABLED' : 'DISABLED'}`);

                // Update all terrain materials
                if (terrainEnabled) {
                    loadedTerrainTiles.forEach(tile => {
                        if (tile.material && tile.material.uniforms && tile.material.uniforms.gradientEnabled) {
                            tile.material.uniforms.gradientEnabled.value = config.elevationGradient;
                        }
                    });
                }
            });

            // Gradient intensity slider
            document.getElementById('gradient-intensity').addEventListener('input', (e) => {
                const intensity = parseFloat(e.target.value);
                config.gradientIntensity = intensity;
                document.getElementById('gradient-intensity-value').textContent = intensity.toFixed(1) + 'x';

                // Update all terrain materials
                if (terrainEnabled) {
                    loadedTerrainTiles.forEach(tile => {
                        if (tile.material && tile.material.uniforms && tile.material.uniforms.gradientIntensity) {
                            tile.material.uniforms.gradientIntensity.value = intensity;
                        }
                    });
                }
            });

            // Focused tiles mode toggle
            document.getElementById('focused-tiles-mode').addEventListener('change', (e) => {
                focusedTilesMode = e.target.checked;

                // Track focused tiles mode toggle
                trackGAEvent('focused_tiles_toggled', {
                    'enabled': focusedTilesMode,
                    'radius_km': config.radius
                });

                console.log(`🎯 Focused Tiles Mode ${focusedTilesMode ? 'ENABLED' : 'DISABLED'} - Restricting tiles to ${config.radius}km search radius`);

                // Clear and reload all map tiles with new materials (masked or unmasked)
                for (const tileKey of loadedTiles.keys()) {
                    unloadTile(tileKey);
                }
                updateVisibleTiles(config.centerLat, config.centerLon, config.radius, currentMapLayer);

                // Clear and reload all terrain tiles with new materials (masked or unmasked)
                if (terrainEnabled) {
                    for (const tileKey of loadedTerrainTiles.keys()) {
                        unloadTerrainTile(tileKey);
                    }
                    updateVisibleTerrainTiles(config.centerLat, config.centerLon, config.radius);
                }
            });

            // Airport label toggle
            document.getElementById('show-airport-labels').addEventListener('change', (e) => {
                // Track airport labels toggle
                trackGAEvent('airport_labels_toggled', {
                    'enabled': e.target.checked
                });

                toggleAirportLabel(e.target.checked);
            });

            // Label display mode toggle (city name vs code)
            document.getElementById('label-show-city').addEventListener('change', (e) => {
                labelShowFullName = e.target.checked;

                // Track city name toggle
                trackGAEvent('label_city_toggled', {
                    'show_city': e.target.checked
                });

                if (airportLabelEnabled && currentAirportCode) {
                    createAirportLabel(currentAirportCode);
                }
            });

            // Label orientation toggle (standing vs flat)
            document.getElementById('label-standing').addEventListener('change', (e) => {
                labelStanding = e.target.checked;

                // Track label orientation toggle
                trackGAEvent('label_orientation_toggled', {
                    'standing': e.target.checked
                });

                if (airportLabelEnabled && currentAirportCode) {
                    createAirportLabel(currentAirportCode);
                }
            });

            // Fog distance slider
            document.getElementById('fog-distance').addEventListener('input', (e) => {
                const distance = parseInt(e.target.value);
                document.getElementById('fog-distance-value').textContent = distance;
                if (scene.fog) {
                    // Keep near as 20% of far distance for good depth effect
                    scene.fog.near = distance * 0.2;
                    scene.fog.far = distance;
                }
            });

            // Line thickness slider
            document.getElementById('line-thickness').addEventListener('input', (e) => {
                const oldThickness = config.lineThickness;
                config.lineThickness = parseFloat(e.target.value);
                document.getElementById('line-thickness-value').textContent = e.target.value;

                const oldUseThickLines = oldThickness > 1;
                const newUseThickLines = config.lineThickness > 1;

                // Update existing trail materials
                aircraftData.forEach((data) => {
                    if (data.trail) {
                        const isThickLine = data.trail.isLine2 || false;

                        // If crossing the threshold, force recreation on next update
                        if (oldUseThickLines !== newUseThickLines) {
                            data.trail.geometry.dispose();
                            data.trail.material.dispose();
                            trailGroup.remove(data.trail);
                            data.trail = null;
                        } else if (isThickLine && data.trail.material) {
                            // Update Line2 material linewidth
                            data.trail.material.linewidth = config.lineThickness;
                            data.trail.material.needsUpdate = true;
                        }
                        // Note: LineBasicMaterial linewidth doesn't work, so no update needed for thin lines
                    }
                });
            });

            // User interaction listeners to reset idle timer
            const userInteractionEvents = ['mousedown', 'mousemove', 'wheel', 'touchstart', 'touchmove', 'keydown'];
            userInteractionEvents.forEach(event => {
                renderer.domElement.addEventListener(event, resetIdleTimer);
            });

            // Start idle timer initially
            resetIdleTimer();

            // Recording & Playback Controls
            document.getElementById('menu-record-btn').addEventListener('click', () => {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });

            document.getElementById('play-pause-btn').addEventListener('click', togglePlayPause);

            document.getElementById('stop-playback-btn').addEventListener('click', stopPlayback);

            document.getElementById('timeline-slider').addEventListener('input', (e) => {
                seekPlayback(parseInt(e.target.value));
            });

            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const speed = parseFloat(e.target.dataset.speed);
                    setPlaybackSpeed(speed);
                });
            });

            document.getElementById('clear-recording-btn').addEventListener('click', () => {
                if (confirm('Clear recording? This cannot be undone.')) {
                    clearRecording();
                }
            });

            document.getElementById('play-recording-btn').addEventListener('click', () => {
                if (recordingData) {
                    startPlayback(recordingData);
                }
            });

            document.getElementById('save-recording-btn').addEventListener('click', saveRecording);

            document.getElementById('load-recording-btn').addEventListener('click', loadRecording);

            // Keyboard shortcuts for playback
            document.addEventListener('keydown', (e) => {
                // Spacebar for play/pause (only when playing back)
                if (e.code === 'Space' && isPlayingBack && !e.target.matches('input, textarea')) {
                    e.preventDefault();
                    togglePlayPause();
                }
            });
        }

        // Remove aircraft from memory that don't pass filters
        function removeFilteredAircraft() {
            const toRemove = [];

            // Find aircraft that don't pass filters
            for (const [hex, data] of aircraftData.entries()) {
                if (data.rawData && !passesFilters(data.rawData)) {
                    toRemove.push(hex);
                }
            }

            // Remove them
            toRemove.forEach(hex => {
                const data = aircraftData.get(hex);

                // Clean up visual objects
                if (data.trail) {
                    trailGroup.remove(data.trail);
                    if (data.trail.geometry) data.trail.geometry.dispose();
                    if (data.trail.material) data.trail.material.dispose();
                }
                if (data.marker) {
                    aircraftGroup.remove(data.marker);
                    if (data.marker.geometry) data.marker.geometry.dispose();
                    if (data.marker.material) data.marker.material.dispose();
                }
                if (data.glow) {
                    aircraftGroup.remove(data.glow);
                    if (data.glow.geometry) data.glow.geometry.dispose();
                    if (data.glow.material) data.glow.material.dispose();
                }
                if (data.label) {
                    data.label.remove();
                    if (activeLabel === data.label) {
                        activeLabel = null;
                    }
                    if (expandedLabel === data.label) {
                        expandedLabel = null;
                    }
                }

                aircraftData.delete(hex);
            });

            console.log(`Removed ${toRemove.length} filtered aircraft from memory`);
        }

        // Apply filters by updating visibility
        function applyFilters() {
            if (filters.removeMode) {
                // In remove mode, actually delete aircraft from memory
                removeFilteredAircraft();
            }

            // Update visuals - they will show/hide based on filters
            updateVisuals();
            // Update stats
            const totalCount = aircraftData.size;
            updateStats(totalCount);
        }

        // Update all aircraft positions with new scale/floor
        function updateAllPositions() {
            // Just re-fetch to recalculate with new settings
            fetchAircraftData();
        }

        // Initialize application
        async function init() {
            initScene();
            initControls();

            // Load world boundaries (lightweight vector borders)
            loadWorldBoundaries('110m');

            document.getElementById('loading').style.display = 'none';

            // Create branding label
            createBrandingLabel();

            // Parse URL parameters for flight search (e.g., ?flight=UAL123)
            parseURLParams();

            // Load random US airport as default (unless ?flight= parameter is present)
            loadRandomUSAirport();

            // Update aircraft data periodically
            updateIntervalId = setInterval(fetchAircraftData, config.updateInterval);

            animate();
        }

        // Start the application
        init();
    </script>
</body>
</html>